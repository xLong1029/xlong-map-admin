import{ij as k,hr as C,dj as q,aw as z,ax as F,a4 as D,i as m,ki as G,kj as O,kk as $,r as E,b3 as P}from"./index.a33ecea7.js";async function B(s,p,f,u,o){const{elevationProvider:y,renderCoordsHelper:r,spatialReference:w}=s,{elevationInfo:I}=p,b=z(I,!0),j=await F(b,w,o);D(o);const i=[],l=new Set,h=new Set;for(const{objectId:c,points:e}of u){const n=f(c);if(m(n)){for(const a of e)i.push(a[2]);l.add(c);continue}n.isDraped&&h.add(c);const t=n.graphic.geometry;v.setFromElevationInfo(G(t,I)),v.updateFeatureExpressionInfoContext(j,n.graphic,p),g.spatialReference=s.spatialReference;for(const{x:a,y:d,z:S}of e)g.x=a,g.y=d,g.z=S!=null?S:0,O(g,y,v,r,x),i.push(x.z)}return{elevations:i,drapedObjectIds:h,failedObjectIds:l}}const v=new k,g=C(0,0,0,q.WGS84),x=new $;async function H(s,p,f){var c;if(m(s)||p.candidates.length===0)return R;const u=(c=s.graphics3DGraphicsByObjectID)!=null?c:s.graphics3DGraphics,o=[],y=[],{renderer:r}=s,w=E(r)&&"arcadeRequired"in r&&r.arcadeRequired?P():null,I=async(e,{graphic:n,graphics3DSymbol:t})=>{const a=await w,d=await s.getRenderingInfoAsync(n,r,a,{signal:f});return m(d)?[]:t.queryForSnapping(e,j,d,f)},{candidates:b,spatialReference:j}=p;for(let e=0;e<b.length;++e){const n=b[e],{objectId:t}=n,a=typeof t=="number"?u==null?void 0:u.get(t):void 0;if(m(a))continue;const{graphics3DSymbol:d}=a;d.symbologySnappingSupported&&(o.push(I(n,a)),y.push(e))}if(o.length===0)return R;const i=await Promise.all(o);D(f);const l=[],h=[];for(let e=0;e<i.length;++e){const n=i[e],t=y[e];for(const a of n)l.push(a),h.push(t)}return{candidates:l,sourceCandidateIndices:h}}const R={candidates:[],sourceCandidateIndices:[]};export{H as a,B as m};
