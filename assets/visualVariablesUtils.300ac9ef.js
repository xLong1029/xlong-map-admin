import{i as h,eQ as v,cc as z}from"./index.a33ecea7.js";import{c as g}from"./color.d55e9401.js";import{A as S}from"./definitions.618cbc79.js";import{L as r}from"./enums.a12f2baf.js";import{l as $}from"./visualVariablesUtils.88d0eb69.js";const E=8388607,m=8388608,x=254,V=255,L=0,y=1,d=s=>(s&m)>>>23,U=s=>s&E,R=s=>d(s)===y?x:V;function T(s){return d(s)===y}function Z(s,e){return((e?m:0)|s)>>>0}const k=(s,e)=>s&&((...t)=>e.warn("DEBUG:",...t))||(()=>null),N=!1;function O(s,e){if(!s||!e)return s;switch(e){case"radius":case"distance":return 2*s;case"diameter":case"width":return s;case"area":return Math.sqrt(s)}return s}function _(s){return{value:s.value,size:v(s.size)}}function a(s){return(s!=null?s:[]).map(e=>_(e))}function c(s){if(typeof s=="string"||typeof s=="number")return v(s);const e=s;return{type:"size",expression:e.expression,stops:a(e.stops)}}const p=s=>{const e=[],t=[],n=a(s),o=n.length;for(let i=0;i<6;i++){const l=n[Math.min(i,o-1)];e.push(l.value),t.push(l.size==null?S:z(l.size))}return{values:new Float32Array(e),sizes:new Float32Array(t)}};function P(s){var n;const e=s&&s.length>0?{}:null,t=e?{}:null;if(!e||!t)return{vvFields:e,vvRanges:t};for(const o of s)if(o.field&&(e[o.type]=o.field),o.type==="size"){t.size||(t.size={});const i=o;switch($(i)){case r.SIZE_MINMAX_VALUE:t.size.minMaxValue={minDataValue:i.minDataValue,maxDataValue:i.maxDataValue,minSize:c(i.minSize),maxSize:c(i.maxSize)};break;case r.SIZE_SCALE_STOPS:t.size.scaleStops={stops:a(i.stops)};break;case r.SIZE_FIELD_STOPS:if(i.levels){const l={};for(const u in i.levels)l[u]=p(i.levels[u]);t.size.fieldStops={type:"level-dependent",levels:l}}else t.size.fieldStops={type:"static",...p(i.stops)};break;case r.SIZE_UNIT_VALUE:t.size.unitValue={unit:i.valueUnit,valueRepresentation:(n=i.valueRepresentation)!=null?n:void 0}}}else if(o.type==="color")t.color=I(o);else if(o.type==="opacity")t.opacity=A(o);else if(o.type==="rotation"){const i=o;t.rotation={type:i.rotationType}}return{vvFields:e,vvRanges:t}}function A(s){const e={values:[0,0,0,0,0,0,0,0],opacities:[0,0,0,0,0,0,0,0]};if(typeof s.field=="string"){if(!s.stops)return null;{if(s.stops.length>8)return null;const t=s.stops;for(let n=0;n<8;++n){const o=t[Math.min(n,t.length-1)];e.values[n]=o.value,e.opacities[n]=o.opacity}}}else{if(!(s.stops&&s.stops.length>=0))return null;{const t=s.stops&&s.stops.length>=0?s.stops[0].opacity:0;for(let n=0;n<8;n++)e.values[n]=1/0,e.opacities[n]=t}}return e}function f(s,e,t){s[4*e+0]=t.r/255,s[4*e+1]=t.g/255,s[4*e+2]=t.b/255,s[4*e+3]=t.a}function I(s){if(h(s)||s.normalizationField)return null;const e={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};if(typeof s.field=="string"){if(!s.stops)return null;{if(s.stops.length>8)return null;e.field=s.field;const t=s.stops;for(let n=0;n<8;++n){const o=t[Math.min(n,t.length-1)];e.values[n]=o.value,f(e.colors,n,o.color)}}}else{if(!(s.stops&&s.stops.length>=0))return null;{const t=s.stops&&s.stops.length>=0&&s.stops[0].color;for(let n=0;n<8;n++)e.values[n]=1/0,f(e.colors,n,t)}}for(let t=0;t<32;t+=4)g(e.colors,t,!0);return e}export{E as a,P as b,y as c,d as e,U as f,R as i,N as l,k as n,T as p,O as r,Z as s,L as u};
