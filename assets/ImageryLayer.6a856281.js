var dt=Object.defineProperty,ht=Object.defineProperties;var yt=Object.getOwnPropertyDescriptors;var Ge=Object.getOwnPropertySymbols;var ft=Object.prototype.hasOwnProperty,gt=Object.prototype.propertyIsEnumerable;var We=(i,r,e)=>r in i?dt(i,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[r]=e,v=(i,r)=>{for(var e in r||(r={}))ft.call(r,e)&&We(i,e,r[e]);if(Ge)for(var e of Ge(r))gt.call(r,e)&&We(i,e,r[e]);return i},J=(i,r)=>ht(i,yt(r));import{aY as n,aZ as l,gO as T,eV as _,gY as vt,a_ as A,fT as q,ek as M,eW as Rt,jY as _e,gP as le,fS as wt,aq as B,t6 as z,ar as K,hx as Oe,b1 as b,md as te,mv as de,mf as he,cU as x,ig as Te,tI as Xe,fI as Ye,nQ as Fe,dL as je,p7 as St,bF as bt,ix as re,bS as ye,tD as xt,mq as It,f8 as Nt,fe as _t,b6 as ie,c5 as V,tJ as se,tK as Ot,cp as Tt,bd as Ce,tL as Ft,tM as jt,tN as Ct,aX as Pt,as as Dt,tO as Mt,tP as At,t8 as Vt,tw as $t,ta as Jt,t9 as qt,mk as Lt,ml as zt,tu as Et,mj as Ut,mm as kt,bb as Qt,e5 as Ht,gU as Bt,tr as Gt,gX as Wt,at as Xt}from"./vendor.47ccae81.js";import{n as Yt,p as Pe,o as Z,i as fe,a as Kt,l as Zt,u as er,k as tr,S as rr,j as ir,Z as sr,b as nr}from"./rasterRendererHelper.9b9c2491.js";import{f as Ke,n as or,l as De,N as ar,P as Ze,O as lr}from"./RasterSymbolizer.d5b48854.js";import{u as ur}from"./pixelUtils.b67e8c28.js";import{c as pr,a as cr}from"./dataUtils.831f8dcc.js";import"./ClassBreaksDefinition.e84bedbe.js";import"./LercCodec.049cf1fe.js";import"./colorUtils.92e1b957.js";var Me;const we=new Set(["raster","raster2","dem","fillraster"]),Se=new Set(["rasters"]),et=i=>i&&i.rasterFunction?j.fromJSON(i):i,Ae=i=>i&&i instanceof j?i.toJSON():i,Ve=i=>(i==null?void 0:i.functionName)&&!i.declaredClass,tt=i=>Ve(i)?new j(i):i;var be;(function(i){i[i.MOSAIC=0]="MOSAIC",i[i.GROUP=1]="GROUP",i[i.ITEM=2]="ITEM"})(be||(be={}));const mr=i=>{if(i==null)return null;i=M(i);const r={};for(const e of Object.keys(i))we.has(e.toLowerCase())?r[e]=et(i[e]):Se.has(e.toLowerCase())&&Array.isArray(i[e])?r[e]=i[e].map(et):r[e]=i[e];return r};let j=Me=class extends q{constructor(i){super(i),this.functionName=null,this.outputPixelType="unknown",this.variableName=null,this.description=null,this.functionDefinition=null,this.thumbnail=null}set functionArguments(i){if(i){const r=Object.keys(i);if(r.some(e=>we.has(e.toLowerCase())&&Ve(i[e]))||r.some(e=>Se.has(e.toLowerCase())&&Array.isArray(i[e])&&i[e].some(t=>Ve(t)))){i=M(i);for(const e of r)we.has(e.toLowerCase())?i[e]=tt(i[e]):Se.has(e.toLowerCase())&&Array.isArray(i[e])&&(i[e]=i[e].map(t=>tt(t)))}}this._set("functionArguments",i)}readFunctionArguments(i,r){return i=r.arguments||r.rasterFunctionArguments,mr(i)}writeFunctionArguments(i,r,e){const t={};for(const s of Object.keys(i))we.has(s.toLowerCase())?t[s]=Ae(i[s]):Se.has(s.toLowerCase())&&Array.isArray(i[s])?t[s]=i[s].map(Ae):t[s]=Ae(i[s]);this.functionDefinition?r.arguments=t:r[e]=t}readFunctionName(i,r){const e=r.rasterFunctionInfos;return r.name||(e&&e.length&&e[0].name!=="None"?e[0].name:r.rasterFunction)}writeFunctionName(i,r,e){this.functionDefinition?r.name=i:r[e]=i}readFunctionType(i){return be[i]}writeFunctionType(i,r,e){r[e]=be[i]}clone(){return new Me({functionName:this.functionName,functionArguments:M(this.functionArguments),outputPixelType:this.outputPixelType,variableName:this.variableName,description:this.description,functionType:this.functionType,functionDefinition:this.functionDefinition,thumbnail:this.thumbnail})}};n([l({json:{type:Object,write:{target:"rasterFunctionArguments"}}})],j.prototype,"functionArguments",null),n([T("functionArguments",["rasterFunctionArguments","arguments"])],j.prototype,"readFunctionArguments",null),n([_("functionArguments")],j.prototype,"writeFunctionArguments",null),n([l({json:{type:String,write:{target:"rasterFunction"}}})],j.prototype,"functionName",void 0),n([T("functionName",["rasterFunction","rasterFunctionInfos","name"])],j.prototype,"readFunctionName",null),n([_("functionName")],j.prototype,"writeFunctionName",null),n([vt({C128:"c128",C64:"c64",F32:"f32",F64:"f64",S16:"s16",S32:"s32",S8:"s8",U1:"u1",U16:"u16",U2:"u2",U32:"u32",U4:"u4",U8:"u8",UNKNOWN:"unknown"},{ignoreUnknown:!1}),l({json:{default:"unknown"}})],j.prototype,"outputPixelType",void 0),n([l({type:String,json:{read:!0,write:!0}})],j.prototype,"variableName",void 0),n([l({type:String,json:{read:!0,write:!0,origins:{"web-document":{read:!1,write:!1}}}})],j.prototype,"description",void 0),n([l({json:{origins:{"web-document":{read:!1,write:!1}}}})],j.prototype,"functionType",void 0),n([T("functionType")],j.prototype,"readFunctionType",null),n([_("functionType")],j.prototype,"writeFunctionType",null),n([l({type:Object,json:{read:{source:"function"},write:{target:"function"},origins:{"web-document":{read:!1,write:!1}}}})],j.prototype,"functionDefinition",void 0),n([l({type:String,json:{read:!0,write:!0,origins:{"web-document":{read:!1,write:!1}}}})],j.prototype,"thumbnail",void 0),j=Me=n([A("esri.layers.support.RasterFunction")],j);const C=j,dr={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767]},hr={simple_scalar:"Simple Scalar",wind_barb:"Wind Barb",single_arrow:"Single Arrow",beaufort_kn:"Beaufort Wind (Knots)",beaufort_m:"Beaufort Wind (MetersPerSecond)",ocean_current_m:"Ocean Current (MetersPerSecond)",ocean_current_kn:"Ocean Current (Knots)"},yr=new Set(["raster-stretch","unique-value","class-breaks","raster-shaded-relief","vector-field","raster-colormap"]);function rt(i){return yr.has(i.type)}function it(i,r){if(!i||!r)return M(i||r);const e=M(i);return r.functionName.toLowerCase()!=="none"&&(st(e.functionArguments).Raster=r),e}function fr(i,r){switch(r=r||{},i.type){case"raster-stretch":return Rr(i,r);case"class-breaks":return wr(i,r);case"unique-value":return Sr(i,r);case"raster-colormap":return br(i,r);case"vector-field":return gr(i,r);case"raster-shaded-relief":return vr(i,r);case"animated-flow":throw new Error("Unsupported rendering rule.")}}function st(i){const r=i.Raster;return r&&r.declaredClass==="esri.layers.support.RasterFunction"?st(r.functionArguments):i}const ge={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function gr(i,r){const e=new C;e.functionName="VectorFieldRenderer";const{dataType:t,bandProperties:s}=r,o=t==="vector-uv";let a,u;s&&s.length===2&&(a=s.map(g=>g.BandName.toLowerCase()).indexOf("magnitude"),u=s.map(g=>g.BandName.toLowerCase()).indexOf("direction")),a!==-1&&a!==null||(a=0,u=1);const p=i.rotationType==="arithmetic"?1:2,m=i.flowRepresentation==="flow-from"?0:1,c=i.visualVariables?i.visualVariables.filter(g=>g.field==="Magnitude")[0]:new Rt,d={magnitudeBandID:a,directionBandID:u,isUVComponents:o,referenceSystem:p,massFlowAngleRepresentation:m,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:"Vector Average",symbologyName:hr[i.style.toLowerCase().replace("-","_")],minimumMagnitude:c.minDataValue,maximumMagnitude:c.maxDataValue,minimumSymbolSize:c.minSize,maximumSymbolSize:c.maxSize};return e.functionArguments=d,e}function vr(i,r){if(r.dataType!=="elevation")return new C;const e=new C;e.functionName="Hillshade";const t=i.hillshadeType==="traditional"?0:1,s=i.scalingType==="none"?1:3,o={HillshadeType:t,SlopeType:s,ZFactor:i.zFactor};return t===0&&(o.Azimuth=i.azimuth,o.Altitude=i.altitude),s===3&&(o.PSPower=i.pixelSizePower,o.PSZFactor=i.pixelSizeFactor),e.functionArguments=o,e.variableName="Raster",i.colorRamp&&(e.functionName="ShadedRelief",o.Colormap=Ke(i.colorRamp,256)),e}function Rr(i,r){const e=new C;e.functionName="Stretch";const t=ge[Yt.toJSON(i.stretchType)],s="u8",o={StretchType:t,Statistics:xr(i.statistics),DRA:i.dynamicRangeAdjustment,UseGamma:i.useGamma,Gamma:i.gamma,ComputeGamma:i.computeGamma};if(i.outputMin!=null&&(o.Min=i.outputMin),i.outputMax!=null&&(o.Max=i.outputMax),t===ge.standardDeviation?(o.NumberOfStandardDeviations=i.numberOfStandardDeviations,e.outputPixelType=s):t===ge.percentClip?(o.MinPercent=i.minPercent,o.MaxPercent=i.maxPercent,e.outputPixelType=s):t===ge.minMax?e.outputPixelType=s:t===ge.sigmoid&&(o.SigmoidStrengthLevel=i.sigmoidStrengthLevel),e.functionArguments=o,e.variableName="Raster",i.colorRamp){const a=i.colorRamp,u=new C,p=or(a);return p?u.functionArguments={colorRamp:p}:!r.convertColorRampToColormap||a.type!=="algorithmic"&&a.type!=="multipart"?u.functionArguments={colorRamp:i.colorRamp.toJSON()}:u.functionArguments={Colormap:Ke(a,256)},u.variableName="Raster",u.functionName="Colormap",u.functionArguments.Raster=e,u}return e}function wr(i,r){const e=[],t=[],s=[],o=[],a=1e-6,{pixelType:u,rasterAttributeTable:p}=r,m=p&&p.features,c=nt(p);if(m&&Array.isArray(m)&&i.classBreakInfos){i.classBreakInfos.forEach((R,W)=>{const N=R.symbol.color;let I;N.a&&m.forEach(S=>{I=S.attributes[i.field],(I>=R.minValue&&I<R.maxValue||W===i.classBreakInfos.length-1&&I>=R.minValue)&&o.push([S.attributes[c],N.r,N.g,N.b])})});const h=u?xe(o,u):o,y=new C;return y.functionName="Colormap",y.functionArguments={},y.functionArguments.Colormap=h,y.variableName="Raster",y}i.classBreakInfos.forEach((h,y)=>{const R=h.symbol&&h.symbol.color;R.a?(y===0?e.push(h.minValue,h.maxValue+a):e.push(h.minValue+a,h.maxValue+a),t.push(y),o.push([y,R.r,R.g,R.b])):s.push(h.minValue,h.maxValue)});const d=u?xe(o,u):o,g=new C;g.functionName="Remap",g.functionArguments={InputRanges:e,OutputValues:t,NoDataRanges:s},g.variableName="Raster";const f=new C;return f.functionName="Colormap",f.functionArguments={Colormap:d,Raster:g},f}function xe(i,r){const e=dr[String(r).toLowerCase()];return e&&i.push([Math.floor(e[0]-1),0,0,0],[Math.ceil(e[1]+1),0,0,0]),i}function nt(i){if(!i)return;const{fields:r}=i,e=r&&r.find(t=>t&&t.name&&t.name.toLowerCase()==="value");return e&&e.name}function Sr(i,r){var e;const t=[],{pixelType:s,rasterAttributeTable:o}=r,a=o&&o.features,u=nt(o),p=(e=i.defaultSymbol)==null?void 0:e.color;let m=!1;if(i.uniqueValueInfos&&(a?a.forEach(g=>{var f;const h=(f=i.uniqueValueInfos.find(y=>String(g.attributes[i.field])===String(y.value)))==null?void 0:f.symbol.color;h?t.push([g.attributes[u],h.r,h.g,h.b]):p&&t.push([g.attributes[u],p.r,p.g,p.b])}):i.uniqueValueInfos.forEach(g=>{var f;if((f=g.symbol.color)==null||!f.a)return;const h=g.symbol.color;isNaN(+g.value)?m=!0:t.push([+g.value,h.r,h.g,h.b])})),m)return null;const c=s&&t.length>0?xe(t,s):t,d=new C;return d.functionName="Colormap",d.functionArguments={},d.functionArguments.Colormap=c,d.variableName="Raster",d}function br(i,r){const e=i.extractColormap();if(!e||e.length===0)return;const{pixelType:t}=r,s=t?xe(e,t):e,o=new C;return o.functionName="Colormap",o.functionArguments={},o.functionArguments.Colormap=s,o}function xr(i){const r=[];return i.forEach(e=>{const t=e;if(Array.isArray(t))r.push(t);else{if(t.min==null||t.max==null)return;const s=[t.min,t.max,t.avg||0,t.stddev||0];r.push(s)}}),r}var $e;const ve=_e()({MT_FIRST:"first",MT_LAST:"last",MT_MIN:"min",MT_MAX:"max",MT_MEAN:"mean",MT_BLEND:"blend",MT_SUM:"sum"}),Je=_e()({esriMosaicNone:"none",esriMosaicCenter:"center",esriMosaicNadir:"nadir",esriMosaicViewpoint:"viewpoint",esriMosaicAttribute:"attribute",esriMosaicLockRaster:"lock-raster",esriMosaicNorthwest:"northwest",esriMosaicSeamline:"seamline"});function Ir(i){let r;switch(i?i.toLowerCase().replace("esrimosaic",""):""){case"byattribute":case"attribute":r="esriMosaicAttribute";break;case"lockraster":r="esriMosaicLockRaster";break;case"center":r="esriMosaicCenter";break;case"northwest":r="esriMosaicNorthwest";break;case"nadir":r="esriMosaicNadir";break;case"viewpoint":r="esriMosaicViewpoint";break;case"seamline":r="esriMosaicSeamline";break;default:r="esriMosaicNone"}return Je.fromJSON(r)}let P=$e=class extends q{constructor(i){super(i),this.ascending=!0,this.itemRenderingRule=null,this.lockRasterIds=null,this.method=null,this.multidimensionalDefinition=null,this.objectIds=null,this.operation=null,this.sortField=null,this.sortValue=null,this.viewpoint=null,this.where=null}readAscending(i,r){return r.ascending!=null?r.ascending:r.sortAscending==null||r.sortAscending}readMethod(i,r){return Ir(r.mosaicMethod||r.defaultMosaicMethod)}readOperation(i,r){const e=r.mosaicOperation,t=r.mosaicOperator&&r.mosaicOperator.toLowerCase(),s=e||(t?ve.toJSON(t):null);return ve.fromJSON(s)||"first"}castSortValue(i){return i==null||typeof i=="string"||typeof i=="number"?i:`${i}`}clone(){return new $e({ascending:this.ascending,itemRenderingRule:M(this.itemRenderingRule),lockRasterIds:M(this.lockRasterIds),method:this.method,multidimensionalDefinition:M(this.multidimensionalDefinition),objectIds:M(this.objectIds),operation:this.operation,sortField:this.sortField,sortValue:this.sortValue,viewpoint:M(this.viewpoint),where:this.where})}};n([l({type:Boolean,json:{write:!0}})],P.prototype,"ascending",void 0),n([T("ascending",["ascending","sortAscending"])],P.prototype,"readAscending",null),n([l({type:C,json:{write:!0}})],P.prototype,"itemRenderingRule",void 0),n([l({type:[le],json:{write:{overridePolicy(){return{enabled:this.method==="lock-raster"}}}}})],P.prototype,"lockRasterIds",void 0),n([l({type:String,json:{type:Je.jsonValues,write:{target:"mosaicMethod",writer:Je.write}}})],P.prototype,"method",void 0),n([T("method",["mosaicMethod","defaultMosaicMethod"])],P.prototype,"readMethod",null),n([l({type:[Pe],json:{write:!0}})],P.prototype,"multidimensionalDefinition",void 0),n([l({type:[le],json:{name:"fids",write:!0}})],P.prototype,"objectIds",void 0),n([l({json:{type:ve.jsonValues,read:{reader:ve.read},write:{target:"mosaicOperation",writer:ve.write}}})],P.prototype,"operation",void 0),n([T("operation",["mosaicOperation","mosaicOperator"])],P.prototype,"readOperation",null),n([l({type:String,json:{write:{overridePolicy(){return{enabled:this.method==="attribute"}}}}})],P.prototype,"sortField",void 0),n([l({type:[String,Number],json:{write:{allowNull:!0,overridePolicy(){return{enabled:this.method==="attribute",allowNull:!0}}}}})],P.prototype,"sortValue",void 0),n([wt("sortValue")],P.prototype,"castSortValue",null),n([l({type:B,json:{write:!0}})],P.prototype,"viewpoint",void 0),n([l({type:String,json:{write:!0}})],P.prototype,"where",void 0),P=$e=n([A("esri.layers.support.MosaicRule")],P);const E=P;let O=class extends q{constructor(){super(...arguments),this.layer=null,this.adjustAspectRatio=void 0,this.bandIds=void 0,this.compression=void 0,this.compressionQuality=void 0,this.compressionTolerance=.01,this.format=null,this.interpolation=null,this.noData=null,this.noDataInterpretation=void 0,this.pixelType=void 0,this.lercVersion=2}writeAdjustAspectRatio(i,r,e){this.layer.version<10.3||(r[e]=i)}writeCompressionQuality(i,r,e){this.format&&this.format.toLowerCase().indexOf("jpg")>-1&&i!=null&&(r[e]=i)}writeCompressionTolerance(i,r,e){this.format==="lerc"&&i!=null&&(r[e]=i)}writeLercVersion(i,r,e){this.format==="lerc"&&this.layer.version>=10.5&&(r[e]=i)}get version(){const i=this.layer;return i.commitProperty("bandIds"),i.commitProperty("format"),i.commitProperty("compressionQuality"),i.commitProperty("compressionTolerance"),i.commitProperty("interpolation"),i.commitProperty("noData"),i.commitProperty("noDataInterpretation"),i.commitProperty("mosaicRule"),i.commitProperty("renderingRule"),i.commitProperty("adjustAspectRatio"),i.commitProperty("pixelFilter"),i.commitProperty("renderer"),i.commitProperty("definitionExpression"),(this._get("version")||0)+1}set version(i){this._set("version",i)}get mosaicRule(){const i=this.layer;let r=i.mosaicRule;const e=i.definitionExpression;return r?e&&e!==r.where&&(r=r.clone(),r.where=e):e&&(r=new E({where:e})),r}get renderingRule(){const i=this.layer;let r=i.renderingRule;const e=i.pixelFilter,t=!i.format||i.format.indexOf("jpg")>-1||i.format.indexOf("png")>-1;return r=this._addResampleRasterFunction(r),t&&!e&&(r=this.combineRendererWithRenderingRule()),r}combineRendererWithRenderingRule(){var i;const r=this.layer,{rasterInfo:e,renderingRule:t,renderer:s}=r;return!s||!rt(s)?t:it(fr(s,{rasterAttributeTable:e.attributeTable,pixelType:e.pixelType,dataType:e.dataType,bandProperties:(i=e.keyProperties)==null?void 0:i.BandProperties,convertColorRampToColormap:r.version<10.6}),t)}_addResampleRasterFunction(i){var r;if(((r=this.layer.renderer)==null?void 0:r.type)!=="vector-field"||(i==null?void 0:i.functionName)==="Resample")return i;const e=this.layer.serviceDataType==="esriImageServiceDataTypeVector-UV"?7:10,t=new C({functionName:"Resample",functionArguments:{ResamplingType:e,InputCellSize:{x:this.layer.pixelSizeX,y:this.layer.pixelSizeY}}});return it(t,i)}};n([l()],O.prototype,"layer",void 0),n([l({json:{write:!0}})],O.prototype,"adjustAspectRatio",void 0),n([_("adjustAspectRatio")],O.prototype,"writeAdjustAspectRatio",null),n([l({json:{write:!0}}),z("layer.bandIds")],O.prototype,"bandIds",void 0),n([l({json:{write:!0}})],O.prototype,"compression",void 0),n([l({json:{write:!0}}),z("layer.compressionQuality")],O.prototype,"compressionQuality",void 0),n([_("compressionQuality")],O.prototype,"writeCompressionQuality",null),n([l({json:{write:!0}}),z("layer.compressionTolerance")],O.prototype,"compressionTolerance",void 0),n([_("compressionTolerance")],O.prototype,"writeCompressionTolerance",null),n([l({json:{write:!0}}),z("layer.format")],O.prototype,"format",void 0),n([l({type:String,json:{read:{reader:Z.read},write:{writer:Z.write}}}),z("layer.interpolation")],O.prototype,"interpolation",void 0),n([l({json:{write:!0}}),z("layer.noData")],O.prototype,"noData",void 0),n([l({type:String,json:{read:{reader:fe.read},write:{writer:fe.write}}}),z("layer.noDataInterpretation")],O.prototype,"noDataInterpretation",void 0),n([l({json:{write:!0}})],O.prototype,"pixelType",void 0),n([l({json:{write:!0}})],O.prototype,"lercVersion",void 0),n([_("lercVersion")],O.prototype,"writeLercVersion",null),n([l({type:Number})],O.prototype,"version",null),n([l({json:{write:!0}})],O.prototype,"mosaicRule",null),n([l({json:{write:!0}})],O.prototype,"renderingRule",null),O=n([A("esri.layers.mixins.ExportImageServiceParameters")],O);let ue=class extends q{constructor(){super(...arguments),this.north=null,this.up=null,this.spatialReference=null}};n([l({type:Number,json:{write:!0}})],ue.prototype,"north",void 0),n([l({type:Number,json:{write:!0}})],ue.prototype,"up",void 0),n([l({type:K,json:{write:!0}})],ue.prototype,"spatialReference",void 0),ue=n([A("esri.rest.support.ImageAngleResult")],ue);const Nr=ue;let Q=class extends q{constructor(){super(...arguments),this.catalogItemVisibilities=null,this.catalogItems=null,this.location=null,this.name=null,this.objectId=null,this.processedValues=null,this.properties=null,this.value=null}};n([l({json:{write:!0}})],Q.prototype,"catalogItemVisibilities",void 0),n([l({type:Oe,json:{write:!0}})],Q.prototype,"catalogItems",void 0),n([l({type:B,json:{write:!0}})],Q.prototype,"location",void 0),n([l({json:{write:!0}})],Q.prototype,"name",void 0),n([l({json:{write:!0}})],Q.prototype,"objectId",void 0),n([l({json:{write:!0}})],Q.prototype,"processedValues",void 0),n([l({json:{write:!0}})],Q.prototype,"properties",void 0),n([l({json:{write:!0}})],Q.prototype,"value",void 0),Q=n([A("esri.rest.support.ImageIdentifyResult")],Q);const _r=Q;let X=class extends q{constructor(){super(...arguments),this.attributes=null,this.location=null,this.locationId=null,this.rasterId=null,this.resolution=null,this.pixelValue=null}};n([l({json:{write:!0}})],X.prototype,"attributes",void 0),n([l({type:B,json:{write:!0}})],X.prototype,"location",void 0),n([l({json:{write:!0}})],X.prototype,"locationId",void 0),n([l({json:{write:!0}})],X.prototype,"rasterId",void 0),n([l({json:{write:!0}})],X.prototype,"resolution",void 0),n([l({json:{write:!0}})],X.prototype,"pixelValue",void 0),X=n([A("esri.rest.support.ImageSample")],X);const Or=X;let Ie=class extends q{constructor(){super(...arguments),this.samples=null}};n([l({type:[Or],json:{write:!0}})],Ie.prototype,"samples",void 0),Ie=n([A("esri.rest.support.ImageSampleResult")],Ie);const Tr=Ie;let Ne=class extends q{constructor(){super(...arguments),this.geometries=null}};n([l({json:{write:!0}})],Ne.prototype,"geometries",void 0),Ne=n([A("esri.rest.support.ImagePixelLocationResult")],Ne);const Fr=Ne;function ot(i){const r=i==null?void 0:i.time;if(r&&(r.start!=null||r.end!=null)){const e=[];r.start!=null&&e.push(r.start),r.end!=null&&e.indexOf(r.end)===-1&&e.push(r.end),i.time=e.join(",")}}async function at(i,r,e){const t=te(i),s=r.geometry?[r.geometry]:[],o=await Te(s),a=r.toJSON();ot(a);const u=o&&o[0];b(u)&&(a.geometry=u.toJSON());const p=de(v(J(v({},t.query),{f:"json"}),a));return he(p,e)}async function jr(i,r,e){var t;const s=r.toJSON();b(s.angleName)&&(s.angleName=s.angleName.join(",")),b(r.point)&&(t=r.point.spatialReference)!=null&&t.imageCoordinateSystem&&(s.point.spatialReference=qe(r.point.spatialReference)),b(r.spatialReference)&&r.spatialReference.imageCoordinateSystem&&(s.spatialReference=ut(r.spatialReference));const o=te(i),a=de(v(J(v({},o.query),{f:"json"}),s)),u=he(a,e),{data:p}=await x(`${o.path}/computeAngles`,u);return p.spatialReference=p.spatialReference?p.spatialReference.geodataXform!=null?new K({wkid:0,imageCoordinateSystem:p.spatialReference}):K.fromJSON(p.spatialReference):null,p.north==="NaN"&&(p.north=null),p.up==="NaN"&&(p.up=null),new Nr(p)}async function Cr(i,r,e){const t=r.toJSON(),{geometries:s}=r;for(let c=0;c<s.length;c++){var o;(o=s[c].spatialReference)!=null&&o.imageCoordinateSystem&&(t.geometries.geometries[c].spatialReference=qe(s[c].spatialReference))}const a=te(i),u=de(v(J(v({},a.query),{f:"json"}),t)),p=he(u,e),{data:m}=await x(`${a.path}/computePixelLocation`,p);return Fr.fromJSON(m)}async function Pr(i,r,e){const t=await at(i,r,e),s=te(i),{data:o}=await x(`${s.path}/computeStatisticsHistograms`,t),{statistics:a}=o;return a!=null&&a.length&&a.forEach(u=>{u.avg=u.mean,u.stddev=u.standardDeviation}),{statistics:a,histograms:o.histograms}}async function Dr(i,r,e){const t=await at(i,r,e),s=te(i),{data:o}=await x(`${s.path}/computeHistograms`,t);return{histograms:o.histograms}}async function Mr(i,r,e){var t,s;const o=r.toJSON();ot(o),(t=o.outFields)!=null&&t.length&&(o.outFields=o.outFields.join(","));const a=await Te(r.geometry),u=a==null?void 0:a[0];b(u)&&(o.geometry=u.toJSON());const p=te(i),m=de(v(J(v({},p.query),{f:"json"}),o)),c=he(m,e),{data:d}=await x(`${p.path}/getSamples`,c),g=d==null||(s=d.samples)==null?void 0:s.map(f=>{const h=f.value==="NaN"||f.value===""?null:f.value.split(" ").map(y=>Number(y));return J(v({},f),{pixelValue:h})});return Tr.fromJSON({samples:g})}async function lt(i,r,e){const t=te(i),s=r.geometry?[r.geometry]:[];return Te(s).then(o=>{const a=r.toJSON(),u=o&&o[0];b(u)&&(a.geometry=JSON.stringify(u.toJSON()));const p=de(v(J(v({},t.query),{f:"json"}),a)),m=he(p,e);return x(t.path+"/identify",m)}).then(o=>_r.fromJSON(o.data))}function qe(i){const{imageCoordinateSystem:r}=i;if(r){const{id:e,referenceServiceName:t}=r;return e!=null?t?{icsid:e,icsns:t}:{icsid:e}:{ics:r}}return i.toJSON()}function ut(i,r){const e=qe(i),{icsid:t,icsns:s,wkid:o}=e;return t!=null?s==null||r!=null&&r.toLowerCase().includes("/"+s.toLowerCase()+"/")?`0:${t}`:JSON.stringify(e):o?o.toString():JSON.stringify(e)}var Le;let ne=Le=class extends q{constructor(){super(...arguments),this.angleNames=null,this.point=null,this.spatialReference=null,this.rasterId=null}clone(){return new Le(M({angleNames:this.angleNames,point:this.point,spatialReference:this.spatialReference,rasterId:this.rasterId}))}};n([l({type:[String],json:{name:"angleName",write:!0}})],ne.prototype,"angleNames",void 0),n([l({type:B,json:{write:!0}})],ne.prototype,"point",void 0),n([l({type:K,json:{write:!0}})],ne.prototype,"spatialReference",void 0),n([l({type:le,json:{write:!0}})],ne.prototype,"rasterId",void 0),ne=Le=n([A("esri.rest.support.ImageAngleParameters")],ne);const Ar=ne;var ze;let G=ze=class extends q{constructor(){super(...arguments),this.geometry=null,this.mosaicRule=null,this.renderingRule=null,this.pixelSize=null,this.raster=void 0,this.timeExtent=null}writeGeometry(i,r,e){i!=null&&(r.geometryType=je(i),r[e]=i.toJSON())}clone(){return new ze(M({geometry:this.geometry,mosaicRule:this.mosaicRule,renderingRule:this.renderingRule,pixelSize:this.pixelSize,raster:this.raster,timeExtent:this.timeExtent}))}};n([l({types:Xe,json:{read:Ye}})],G.prototype,"geometry",void 0),n([_("geometry")],G.prototype,"writeGeometry",null),n([l({type:E,json:{write:!0}})],G.prototype,"mosaicRule",void 0),n([l({type:C,json:{write:!0}})],G.prototype,"renderingRule",void 0),n([l({type:B,json:{write:!0}})],G.prototype,"pixelSize",void 0),n([l({json:{write:!0}})],G.prototype,"raster",void 0),n([l({type:Fe,json:{read:{source:"time"},write:{target:"time"}}})],G.prototype,"timeExtent",void 0),G=ze=n([A("esri.rest.support.ImageHistogramParameters")],G);const pt=G;var Ee;let F=Ee=class extends q{constructor(){super(...arguments),this.geometry=null,this.renderingRules=null,this.pixelSize=null,this.returnGeometry=!0,this.returnCatalogItems=!0,this.returnPixelValues=!0,this.maxItemCount=null,this.timeExtent=null,this.raster=void 0,this.viewId=void 0}writeGeometry(i,r,e){i!=null&&(r.geometryType=je(i),r[e]=JSON.stringify(i.toJSON()))}set mosaicRule(i){let r=i;r&&r.mosaicMethod&&(r=E.fromJSON(J(v({},r.toJSON()),{mosaicMethod:r.mosaicMethod,mosaicOperation:r.mosaicOperation}))),this._set("mosaicRule",r)}writeMosaicRule(i,r,e){i!=null&&(r[e]=JSON.stringify(i.toJSON()))}set renderingRule(i){let r=i;r&&r.rasterFunction&&(r=C.fromJSON(J(v({},r.toJSON()),{rasterFunction:r.rasterFunction,rasterFunctionArguments:r.rasterFunctionArguments}))),this._set("renderingRule",r)}writeRenderingRule(i,r,e){i!=null&&(r[e]=JSON.stringify(i.toJSON()))}writeRenderingRules(i,r,e){i!=null&&(r[e]=JSON.stringify(i.map(t=>t.toJSON())))}writePixelSize(i,r,e){i!=null&&(r[e]=JSON.stringify(i))}writeTimeExtent(i,r,e){if(i!=null){const t=b(i.start)?i.start.getTime():null,s=b(i.end)?i.end.getTime():null;r[e]=t!=null?s!=null?`${t},${s}`:`${t}`:null}}clone(){return new Ee(M({geometry:this.geometry,mosaicRule:this.mosaicRule,renderingRule:this.renderingRule,pixelSize:this.pixelSize,returnGeometry:this.returnGeometry,returnCatalogItems:this.returnCatalogItems,returnPixelValues:this.returnPixelValues,maxItemCount:this.maxItemCount,raster:this.raster,viewId:this.viewId,timeExtent:this.timeExtent}))}};n([l({json:{write:!0}})],F.prototype,"geometry",void 0),n([_("geometry")],F.prototype,"writeGeometry",null),n([l({type:E,json:{write:!0}})],F.prototype,"mosaicRule",null),n([_("mosaicRule")],F.prototype,"writeMosaicRule",null),n([l({type:C,json:{write:!0}})],F.prototype,"renderingRule",null),n([_("renderingRule")],F.prototype,"writeRenderingRule",null),n([l({type:[C],json:{write:!0}})],F.prototype,"renderingRules",void 0),n([_("renderingRules")],F.prototype,"writeRenderingRules",null),n([l({type:B,json:{write:!0}})],F.prototype,"pixelSize",void 0),n([_("pixelSize")],F.prototype,"writePixelSize",null),n([l({type:Boolean,json:{write:!0}})],F.prototype,"returnGeometry",void 0),n([l({type:Boolean,json:{write:!0}})],F.prototype,"returnCatalogItems",void 0),n([l({type:Boolean,json:{write:!0}})],F.prototype,"returnPixelValues",void 0),n([l({type:Number,json:{write:!0}})],F.prototype,"maxItemCount",void 0),n([l({type:Fe,json:{write:{target:"time"}}})],F.prototype,"timeExtent",void 0),n([_("timeExtent")],F.prototype,"writeTimeExtent",null),n([l({json:{write:!0}})],F.prototype,"raster",void 0),n([l({json:{write:!0}})],F.prototype,"viewId",void 0),F=Ee=n([A("esri.rest.support.ImageIdentifyParameters")],F);const ct=F;var Ue;let pe=Ue=class extends q{constructor(){super(...arguments),this.geometries=null,this.rasterId=null}writeGeometry(i,r,e){r.geometries={geometryType:"esriGeometryPoint",geometries:i.map(t=>t.toJSON())}}clone(){return new Ue({geometries:this.geometries.map(i=>i.clone()),rasterId:this.rasterId})}};n([l({type:[B],json:{write:!0}})],pe.prototype,"geometries",void 0),n([_("geometries")],pe.prototype,"writeGeometry",null),n([l({type:le,json:{write:!0}})],pe.prototype,"rasterId",void 0),pe=Ue=n([A("esri.rest.support.ImagePixelLocationParameters")],pe);const Vr=pe;var ke;let $=ke=class extends q{constructor(){super(...arguments),this.geometry=null,this.interpolation="nearest",this.mosaicRule=null,this.outFields=null,this.pixelSize=null,this.returnFirstValueOnly=!0,this.sampleDistance=null,this.sampleCount=null,this.sliceId=null,this.timeExtent=null}writeGeometry(i,r,e){i!=null&&(r.geometryType=je(i),r[e]=i.toJSON())}set locations(i){if(i!=null&&i.length){const r=new St({spatialReference:i[0].spatialReference});r.points=i.map(e=>[e.x,e.y]),this._set("locations",i),this.geometry=r}}clone(){return new ke(M({geometry:this.geometry,locations:this.locations,interpolation:this.interpolation,mosaicRule:this.mosaicRule,outFields:this.outFields,raster:this.raster,returnFirstValueOnly:this.returnFirstValueOnly,sampleDistance:this.sampleDistance,sampleCount:this.sampleCount,sliceId:this.sliceId,pixelSize:this.pixelSize,timeExtent:this.timeExtent}))}};n([l({types:Xe,json:{read:Ye}})],$.prototype,"geometry",void 0),n([_("geometry")],$.prototype,"writeGeometry",null),n([l({type:String,json:{type:Z.jsonValues,read:Z.read,write:Z.write}})],$.prototype,"interpolation",void 0),n([l({type:E,json:{write:!0}})],$.prototype,"mosaicRule",void 0),n([l({type:[String],json:{write:!0}})],$.prototype,"outFields",void 0),n([l({type:B,json:{write:!0}})],$.prototype,"pixelSize",void 0),n([l({type:String,json:{write:!0}})],$.prototype,"raster",void 0),n([l({type:Boolean,json:{write:!0}})],$.prototype,"returnFirstValueOnly",void 0),n([l({type:Number,json:{write:!0}})],$.prototype,"sampleDistance",void 0),n([l({type:Number,json:{write:!0}})],$.prototype,"sampleCount",void 0),n([l({type:Number,json:{write:!0}})],$.prototype,"sliceId",void 0),n([l({type:Fe,json:{read:{source:"time"},write:{target:"time"}}})],$.prototype,"timeExtent",void 0),$=ke=n([A("esri.rest.support.ImageSampleParameters")],$);const $r=$,mt=bt.getLogger("esri.layers.mixins.ArcGISImageService"),Qe=_e()({U1:"u1",U2:"u2",U4:"u4",U8:"u8",S8:"s8",U16:"u16",S16:"s16",U32:"u32",S32:"s32",F32:"f32",F64:"f64",C64:"c64",C128:"c128",UNKNOWN:"unknown"}),Jr=new Set(["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"]),qr=Mt(At,{min:0,max:255});function Lr(i){if(!i)return null;const r=JSON.stringify(i).match(/"rasterFunction":"(.*?")/gi),e=r==null?void 0:r.map(t=>t.replace('"rasterFunction":"',"").replace('"',""));return e?e.join("/"):null}const zr=i=>{let r=class extends i{constructor(){super(...arguments),this._functionRasterInfos={},this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this._symbolizer=null,this._defaultServiceMosaicRule=null,this._serviceSourceType=null,this._serviceSupportsMosaicRule=null,this.rasterAttributeTableFieldPrefix="Raster.",this.adjustAspectRatio=null,this.bandCount=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalInfo=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType="polygon",this.typeIdField=null,this.types=[],this.pixelSizeX=null,this.pixelSizeY=null,this.pixelFilter=null,this.raster=void 0,this.viewId=void 0,this.renderer=null,this.rasterAttributeTable=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=null}initialize(){this._set("exportImageServiceParameters",new O({layer:this}))}readDefaultServiceMosaicRule(e,t){return this._serviceSupportsMosaicRule?E.fromJSON(t):null}readServiceSourceType(e,t){return this._isMosaicDataset(t)?"mosaic-dataset":"raster-dataset"}readServiceSupportsMosaicRule(e,t){return this._isMosaicRuleSupported(t)}get rasterFunctionNamesIndex(){const e=new Map;return!this.rasterFunctionInfos||b(this.rasterFunctionInfos)&&this.rasterFunctionInfos.length<1||b(this.rasterFunctionInfos)&&this.rasterFunctionInfos.forEach(t=>{e.set(t.name.toLowerCase().replace(/ /gi,"_"),t.name)}),e}readBandIds(e,t){if(Array.isArray(e)&&e.length>0&&e.every(s=>typeof s=="number"))return e}readCapabilities(e,t){return this._readCapabilities(t)}writeCompressionQuality(e,t,s){e!=null&&this.format!=="lerc"&&(t[s]=e)}writeCompressionTolerance(e,t,s){this.format==="lerc"&&e!=null&&(t[s]=e)}get fieldsIndex(){return this.fields?new Nt(this.fields):null}set format(e){e&&Jr.has(e.toLowerCase())&&this._set("format",e.toLowerCase())}readFormat(e,t){return t.serviceDataType==="esriImageServiceDataTypeVector-UV"||t.serviceDataType==="esriImageServiceDataTypeVector-MagDir"||this.pixelFilter!=null?"lerc":"jpgpng"}readMinScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}readMaxScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}set mosaicRule(e){let t=e;t&&t.mosaicMethod&&(t=E.fromJSON(J(v({},t.toJSON()),{mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation}))),this._set("mosaicRule",t)}readMosaicRule(e,t){const s=e||t.mosaicRule;return s?E.fromJSON(s):this._isMosaicRuleSupported(t)?E.fromJSON(t):null}writeMosaicRule(e,t,s){let o=this.mosaicRule;const a=this.definitionExpression;o?a&&a!==o.where&&(o=o.clone(),o.where=a):a&&(o=new E({where:a})),this._isValidCustomizedMosaicRule(o)&&(t[s]=o.toJSON())}writeNoData(e,t,s){e!=null&&typeof e=="number"&&(t[s]=qr(e))}readObjectIdField(e,t){if(!e){const s=t.fields.filter(o=>o.type==="esriFieldTypeOID"||o.type==="oid");e=s&&s[0]&&s[0].name}return e}get parsedUrl(){return this.url?_t(this.url):null}readRenderer(e,t,s){var o,a;const u=t==null||(o=t.layerDefinition)==null||(a=o.drawingInfo)==null?void 0:a.renderer,p=er(u,s);return p==null?null:(p.type==="vector-field"&&t.symbolTileSize&&!u.symbolTileSize&&(p.symbolTileSize=t.symbolTileSize),rt(p)||mt.warn("ArcGISImageService","Imagery layer doesn't support given renderer type."),p)}writeRenderer(e,t,s){t.layerDefinition=t.layerDefinition||{},t.layerDefinition.drawingInfo=t.layerDefinition.drawingInfo||{},t.layerDefinition.drawingInfo.renderer=e.toJSON(),e.type==="vector-field"&&(t.symbolTileSize=e.symbolTileSize)}get rasterFields(){const e=this.rasterAttributeTableFieldPrefix||"Raster.",t=new re({name:"Raster.ItemPixelValue",alias:"Item Pixel Value",domain:null,editable:!1,length:50,type:"string"}),s=new re({name:"Raster.ServicePixelValue",alias:"Service Pixel Value",domain:null,editable:!1,length:50,type:"string"}),o=new re({name:"Raster.ServicePixelValue.Raw",alias:"Raw Service Pixel Value",domain:null,editable:!1,length:50,type:"string"});let a=this.fields?M(this.fields):[];a.push(s),this.capabilities.operations.supportsQuery&&this.fields&&this.fields.length>0&&a.push(t),this.version>=10.4&&b(this.rasterFunctionInfos)&&this.rasterFunctionInfos.some(p=>p.name.toLowerCase()==="none")&&a.push(o),b(this.rasterFunctionInfos)&&this.rasterFunctionInfos.filter(p=>p.name.toLowerCase()!=="none").forEach(p=>{a.push(new re({name:"Raster.ServicePixelValue."+p.name,alias:p.name,domain:null,editable:!1,length:50,type:"string"}))}),this.pixelFilter==null||this.serviceDataType!=="esriImageServiceDataTypeVector-UV"&&this.serviceDataType!=="esriImageServiceDataTypeVector-MagDir"||(a.push(new re({name:"Raster.Magnitude",alias:"Magnitude",domain:null,editable:!1,type:"double"})),a.push(new re({name:"Raster.Direction",alias:"Direction",domain:null,editable:!1,type:"double"})));const u=this.rasterInfo.attributeTable&&this.rasterInfo.attributeTable.fields||null;if(u&&u.length>0){const p=u.filter(m=>m.type!=="esriFieldTypeOID"&&m.name.toLowerCase()!=="value").map(m=>{const c=M(m);return c.name=e+m.name,c});a=a.concat(p)}return a}set renderingRule(e){let t=e;t&&t.rasterFunction&&(t=C.fromJSON(J(v({},t.toJSON()),{rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments}))),this._set("renderingRule",t)}readRenderingRule(e,t){const s=t.rasterFunctionInfos;return t.renderingRule||s&&s.length&&s[0].name!=="None"?C.fromJSON(t.renderingRule||{rasterFunctionInfos:t.rasterFunctionInfos}):null}writeRenderingRule(e,t,s){this._isRFTJson(e)||(t[s]=e.toJSON())}readSpatialReference(e,t){const s=e||t.extent.spatialReference;return s?K.fromJSON(s):null}readPixelType(e){return Qe.fromJSON(e)||e}writePixelType(e,t,s){(ie(this.serviceRasterInfo)||this.pixelType!==this.serviceRasterInfo.pixelType)&&(t[s]=Qe.toJSON(e))}readVersion(e,t){let s=t.currentVersion;return s||(s=t.hasOwnProperty("fields")||t.hasOwnProperty("timeInfo")?10:9.3),s}applyFilter(e){let t=e;return this.pixelFilter&&(t=this._clonePixelData(e),this.pixelFilter(t)),t}async applyRenderer(e,t){let s=e;if(!this._isPicture()&&this.renderer&&this._symbolizer&&!this.pixelFilter){const o=JSON.stringify(this._cachedRendererJson)!==JSON.stringify(this.renderer.toJSON()),a=this._rasterJobHandler.instance,{bandIds:u}=this;if(a){o&&(this._symbolizer.bind(),await a.updateSymbolizer(this._symbolizer,t),this._cachedRendererJson=this.renderer.toJSON());const p=await a.symbolize(v({bandIds:u},e),t);s={extent:e.extent,pixelBlock:p}}else s={extent:e.extent,pixelBlock:this._symbolizer.symbolize(v({bandIds:u},e))}}return s}destroy(){this._shutdownJobHandler()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}async computeAngles(e,t){if(await this._fetchCapabilities(t==null?void 0:t.signal),!this.capabilities.operations.supportsComputeAngles)throw new V("imagery-layer:compute-angles","this operation is not supported on the input image service");return e=se(Ar,e).clone(),jr(this.url,e,this._getRequestOptions(t))}async computePixelSpaceLocations(e,t){if(await this._fetchCapabilities(t==null?void 0:t.signal),!this.capabilities.operations.supportsComputePixelLocation)throw new V("imagery-layer:compute-pixel-space-locations","this operation is not supported on the input image service");return e=se(Vr,e).clone(),Cr(this.url,e,this._getRequestOptions(t))}async computeHistograms(e,t){if(await this._fetchCapabilities(t==null?void 0:t.signal),!this.capabilities.operations.supportsComputeHistograms)throw new V("imagery-layer:compute-histograms","this operation is not supported on the input image service");e=se(pt,e).clone();const{raster:s,mosaicRule:o,renderingRule:a}=this;return a&&e.renderingRule==null&&(e.renderingRule=a),o&&e.mosaicRule==null&&(e.mosaicRule=o),s&&e.raster==null&&(e.raster=s),Dr(this.url,e,this._getRequestOptions(t))}async computeStatisticsHistograms(e,t){if(await this._fetchCapabilities(t==null?void 0:t.signal),!this.capabilities.operations.supportsComputeStatisticsHistograms)throw new V("imagery-layer:compute-statistics-histograms","this operation is not supported on the input image service");e=se(pt,e).clone();const{raster:s,mosaicRule:o,renderingRule:a}=this;return a&&e.renderingRule==null&&(e.renderingRule=a),o&&e.mosaicRule==null&&(e.mosaicRule=o),s&&e.raster==null&&(e.raster=s),Pr(this.url,e,this._getRequestOptions(t))}getField(e){const{fieldsIndex:t}=this;return b(t)?t.get(e):void 0}getFieldDomain(e,t){const s=this.getField(e);return s?s.domain:null}fetchImage(e,t,s,o={}){if(e==null||t==null||s==null)return Promise.reject(new V("imagery-layer:fetch-image","Insufficient parameters for requesting an image. A valid extent, width and height values are required."));const a=this.renderer||this._symbolizer?this.generateRasterInfo(this.renderingRule,{signal:o.signal}):null;return Ot(a).then(u=>{u&&(this.rasterInfo=u);const p={imageServiceParameters:this.getExportImageServiceParameters(e,t,s,o.timeExtent),imageProps:{extent:e,width:t,height:s,format:this.format},requestAsImageElement:o.requestAsImageElement&&!this.pixelFilter||!1,signal:o.signal};return this._requestArrayBuffer(p)})}fetchKeyProperties(e){const t=e&&e.renderingRule&&e.renderingRule.toJSON();return x(this.parsedUrl.path+"/keyProperties",{query:this._getQueryParams({renderingRule:this.version>=10.3&&t?JSON.stringify(t):null})}).then(s=>s.data)}fetchRasterAttributeTable(e){const t=e&&e.renderingRule&&e.renderingRule.toJSON();return this.version<10.1?Promise.reject(new V("#fetchRasterAttributeTable()","Failed to get rasterAttributeTable")):x(this.parsedUrl.path+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:this.version>=10.3&&t?JSON.stringify(t):null})}).then(s=>Oe.fromJSON(s.data))}async getCatalogItemRasterInfo(e,t){const s=x(this.parsedUrl.path+"/"+e+"/info",v({query:this._getQueryParams()},t)).then(m=>m.data),o=x(this.parsedUrl.path+"/"+e+"/info/keyProperties",v({query:this._getQueryParams()},t)).then(m=>m.data).catch(()=>{}),a=await Promise.all([s,o]);if(!a[0])return;const u=ye.fromJSON(a[0].extent),p=a[0].statistics?a[0].statistics.map(m=>({min:m[0],max:m[1],avg:m[2],stddev:m[3]})):null;return new De({bandCount:a[0].bandCount,extent:u,spatialReference:u.sr,pixelSize:new B({x:a[0].pixelSizeX,y:a[0].pixelSizeY,spatialReference:u.sr}),pixelType:a[0].pixelType.toLowerCase(),statistics:p,histograms:a[0].histograms,keyProperties:a[1]||{}})}async getCatalogItemICSInfo(e,t){const{data:s}=await x(this.parsedUrl.path+"/"+e+"/info/ics",v({query:this._getQueryParams()},t)),o=s&&s.ics;if(!o)return;let a=null;try{a=(await x(this.parsedUrl.path+"/"+e+"/info",v({query:this._getQueryParams()},t))).data.extent}catch{}if(!a||!a.spatialReference)return{ics:o,icsToPixelTransform:null,icsExtent:null,northDirection:null};const u=this.version>=10.7?x(this.parsedUrl.path+"/"+e+"/info/icstopixel",v({query:this._getQueryParams()},t)).then(w=>w.data).catch(()=>({})):{},p=a.spatialReference,m={geometries:JSON.stringify({geometryType:"esriGeometryEnvelope",geometries:[a]}),inSR:p.wkid||JSON.stringify(p),outSR:"0:"+e},c=x(this.parsedUrl.path+"/project",v({query:this._getQueryParams(m)},t)).then(w=>w.data).catch(()=>({})),d=5,g=(a.xmin+a.xmax)/2,f=(a.ymax-a.ymin)/(d+1),h=a.ymin+f,y=[];for(let w=0;w<d;w++)y.push({x:g,y:h+f*w});const R={geometries:JSON.stringify({geometryType:"esriGeometryPoint",geometries:y}),inSR:p.wkid||JSON.stringify(p),outSR:"0:"+e},W=x(this.parsedUrl.path+"/project",v({query:this._getQueryParams(R)},t)).then(w=>w.data).catch(()=>({})),N=await Promise.all([u,c,W]);let I=N[0].ipxf;if(I==null){var S,k,Y;const w=(S=o.geodataXform)==null?void 0:S.xf_0;(w==null||(k=w.name)==null?void 0:k.toLowerCase())==="topup"&&(w==null||(Y=w.coefficients)==null?void 0:Y.length)===6&&(I={affine:{name:"ics [sensor: Frame] to pixel (column, row) transformation",coefficients:w.coefficients,cellsizeRatio:0,type:"GeometricXform"}})}const oe=ye.fromJSON(N[1]&&N[1].geometries&&N[1].geometries[0]);oe&&(oe.spatialReference=new K({wkid:0,imageCoordinateSystem:o}));const D=N[2].geometries?N[2].geometries.filter(w=>w!=null&&w.x!=null&&w.y!=null&&w.x!=="NaN"&&w.y!=="NaN"):[],ee=D.length;if(ee<3)return{ics:o,icsToPixelTransform:I,icsExtent:oe,northDirection:null};let ae=0,Re=0,H=0,ce=0;for(let w=0;w<ee;w++)ae+=D[w].x,Re+=D[w].y,H+=D[w].x*D[w].x,ce+=D[w].x*D[w].y;const L=(ee*ce-ae*Re)/(ee*H-ae*ae);let me=0;const He=D[d-1].x>D[0].x,Be=D[d-1].y>D[0].y;return L===1/0?me=Be?90:270:L===0?me=He?0:180:L>0?me=He?180*Math.atan(L)/Math.PI:180*Math.atan(L)/Math.PI+180:L<0&&(me=Be?180+180*Math.atan(L)/Math.PI:360+180*Math.atan(L)/Math.PI),{ics:o,icsToPixelTransform:I,icsExtent:oe,northDirection:me}}async generateRasterInfo(e,t){if((!e||e.functionName.toLowerCase()==="none"||this._isVectorFieldResampleFunction(e))&&b(this.serviceRasterInfo))return this.serviceRasterInfo;const s=Lr(e);if(this._functionRasterInfos[s])return this._functionRasterInfos[s];const o=this._generateRasterInfo(e,t);this._functionRasterInfos[s]=o;try{return await o}catch{return this._functionRasterInfos[s]=null,null}}getExportImageServiceParameters(e,t,s,o){e=e.clone().shiftCentralMeridian();const a=ut(e.spatialReference,this.parsedUrl.path);b(this.serviceRasterInfo)&&this.pixelType!==this.serviceRasterInfo.pixelType&&(this.exportImageServiceParameters.pixelType=this.pixelType);const u=this.exportImageServiceParameters.toJSON(),{bandIds:p,noData:m}=u;let{renderingRule:c}=u;const d=this.renderingRule&&this.renderingRule.functionName.toLowerCase()!=="none",g=!this.renderer||this.renderer.type==="raster-stretch";if(p!=null&&p.length&&d&&g){const y={rasterFunction:"ExtractBand",rasterFunctionArguments:{BandIds:p}};if(c.rasterFunction==="Stretch")y.rasterFunctionArguments.Raster=c.rasterFunctionArguments.Raster,c.rasterFunctionArguments.Raster=y;else if(c.rasterFunction==="Colormap"){const R=c.rasterFunctionArguments.Raster;(R==null?void 0:R.rasterFunction)==="Stretch"?(y.rasterFunctionArguments.Raster=R.rasterFunctionArguments.Raster,R.rasterFunctionArguments.Raster=y):(y.rasterFunctionArguments.Raster=R,c.rasterFunctionArguments.Raster=y)}else y.rasterFunctionArguments.Raster=c,c=y;u.bandIds=void 0}else u.bandIds=p==null?void 0:p.join(",");m instanceof Array&&m.length>0&&(u.noData=m.join(","));const f=this._serviceSupportsMosaicRule?this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,o):null;u.mosaicRule=f&&JSON.stringify(f),u.renderingRule=c&&JSON.stringify(c);const h={};if(o){const{start:y,end:R}=o.toJSON();y&&R&&y===R?h.time=""+y:y==null&&R==null||(h.time=`${y==null?"null":y},${R==null?"null":R}`)}return v(v({bbox:e.xmin+","+e.ymin+","+e.xmax+","+e.ymax,bboxSR:a,imageSR:a,size:t+","+s},u),h)}async getSamples(e,t){if(await this._fetchCapabilities(t==null?void 0:t.signal),!this.capabilities.operations.supportsGetSamples)throw new V("imagery-layer:get-samples","getSamples operation is not supported on the input image service");e=se($r,e).clone();const{raster:s}=this;return s&&e.raster==null&&(e.raster=s),Mr(this.url,e,this._getRequestOptions(t))}async identify(e,t){if(await this._fetchCapabilities(t==null?void 0:t.signal),!this.capabilities.operations.supportsIdentify)throw new V("imagery-layer:query-rasters","query operation is not supported on the input image service");e=se(ct,e).clone();const{raster:s,mosaicRule:o,renderingRule:a}=this;if(a&&e.renderingRule==null&&(e.renderingRule=a),o&&e.mosaicRule==null){const u=this._combineMosaicRuleWithTimeExtent(o,e.timeExtent);e.mosaicRule=Tt(u)}return s&&e.raster==null&&(e.raster=s),lt(this.url,e,this._getRequestOptions(t))}createQuery(){const e=new Ce;return e.outFields=["*"],e.returnGeometry=!0,e.where=this.definitionExpression||"1=1",e}async queryRasters(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),Ft(this.url,e,t)}async queryObjectIds(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),jt(this.url,e,t)}async queryRasterCount(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),Ct(this.url,e,t)}queryVisibleRasters(e,t){if(!e)return Promise.reject(new V("imagery-layer: query-visible-rasters","missing query parameter"));const{pixelSize:s,returnDomainValues:o,returnTopmostRaster:a,showNoDataRecords:u}=t||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1};let p=!1,m=null,c=null;const d="raster.servicepixelvalue",g=this.rasterFunctionNamesIndex;if(b(e.outFields)&&(p=e.outFields.some(I=>I.toLowerCase().indexOf(d)===-1),this.version>=10.4)){const I=e.outFields.filter(S=>S.toLowerCase().indexOf(d)>-1&&S.length>d.length).map(S=>{const k=S.slice(d.length+1);return[this._updateRenderingRulesFunctionName(k,g),k]});m=I.map(S=>new C({functionName:S[0]})),c=I.map(S=>S[1]),m.length===0?this.renderingRule?(m.push(this.renderingRule),c.push(this.renderingRule.functionName)):m=null:this.renderingRule&&!m.some(S=>S.functionName===this.renderingRule.functionName)&&(m.push(this.renderingRule),c.push(this.renderingRule.functionName))}const f=ie(e.outSpatialReference)||e.outSpatialReference.equals(this.spatialReference),h=e.timeExtent||this.timeExtent,y=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,h),R=this._getQueryParams({geometry:e.geometry,timeExtent:h,mosaicRule:y,renderingRule:this.version<10.4?this.renderingRule:null,renderingRules:m,pixelSize:s,returnCatalogItems:p,returnGeometry:f,raster:this.raster,maxItemCount:a?1:null});delete R.f;const W=new ct(R),N=this.generateRasterInfo(this.renderingRule);return new Promise(I=>{N.then(()=>{lt(this.url,W,{signal:t==null?void 0:t.signal,query:v({},this.customParameters)}).then(S=>{var k;const Y=e.outFields,oe=S.value.toLowerCase().indexOf("nodata")>-1;if(p&&!f&&S!=null&&(k=S.catalogItems)!=null&&k.features.length&&(u||!oe)){const D=this.objectIdField||"ObjectId",ee=S.catalogItems.features,ae=ee.map(H=>H.attributes&&H.attributes[D]),Re=new Ce({objectIds:ae,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[D]});return this.queryRasters(Re).then(H=>{H&&H.features&&H.features.length>0&&H.features.forEach(ce=>{ee.forEach(L=>{L.attributes[D]===ce.attributes[D]&&(L.geometry=new Pt(ce.geometry),L.geometry.spatialReference=e.outSpatialReference)})}),I(this._processVisibleRastersResponse(S,{returnDomainValues:o,templateRRFunctionNames:c,showNoDataRecords:u,templateFields:Y}))}).catch(()=>{throw new V("imagery-layer:query-visible-rasters","encountered error when querying visible rasters geometry")})}I(this._processVisibleRastersResponse(S,{returnDomainValues:o,templateRRFunctionNames:c,showNoDataRecords:u,templateFields:Y}))}).catch(()=>{throw new V("imagery-layer:query-visible-rasters","encountered error when querying visible rasters")})})})}async fetchVariableStatisticsHistograms(e,t){const s=x(this.parsedUrl.path+"/statistics",{query:this._getQueryParams({variable:e}),signal:t}).then(u=>{var p;return(p=u.data)==null?void 0:p.statistics}),o=x(this.parsedUrl.path+"/histograms",{query:this._getQueryParams({variable:e}),signal:t}).then(u=>{var p;return(p=u.data)==null?void 0:p.histograms}),a=await Promise.all([s,o]);return a[0]&&a[0].forEach(u=>{u.avg=u.mean,u.stddev=u.standardDeviation}),{statistics:a[0]||null,histograms:a[1]||null}}async createStreamlinesMesh(e,t){const s=this._rasterJobHandler.instance;return s?s.createStreamlinesMesh(e,t):pr(e.rendererSettings,e.flowData,b(t.signal)?t.signal:new AbortController().signal)}async _fetchService(e){await this._fetchServiceInfo(e),b(this.serviceRasterInfo)&&!this.rasterInfo&&(this.rasterInfo=this.serviceRasterInfo);const t=this.sourceJSON,s=b(this.serviceRasterInfo)?Promise.resolve(this.serviceRasterInfo):this._fetchAuxiliaryRasterInfo({serviceInfo:t,signal:e}).then(u=>(this._set("serviceRasterInfo",u),u)),o=this.renderingRule&&this.renderingRule.functionName.toLowerCase()!=="none"?this.generateRasterInfo(this.renderingRule,{signal:e}):null,a=this._getRasterFunctionInfos();return Promise.all([s,o,a]).then(u=>{u[1]?this._set("rasterInfo",u[1]):this._set("rasterInfo",u[0]),u[2]&&this._set("rasterFunctionInfos",u[2]),this.renderer&&!this._isSupportedRenderer(this.renderer)&&(this.renderer=null,mt.warn("ArcGISImageService","Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")),this._configDefaultRenderer(),this.watch("renderer",()=>this._configDefaultRenderer()),this.watch("renderingRule",m=>{(this.renderer||this._symbolizer||this.popupEnabled&&this.popupTemplate)&&this.generateRasterInfo(m).then(c=>{c&&(this.rasterInfo=c)})});const p=b(this.serviceRasterInfo)&&this.serviceRasterInfo.multidimensionalInfo;p&&this._updateMultidimensionalDefinition(p)})}_combineMosaicRuleWithTimeExtent(e,t){const s=this.timeInfo;if(ie(e)||ie(this.multidimensionalInfo)||ie(t)||ie(s==null?void 0:s.startField))return e;const{startField:o}=s;var a;if(e=e.clone(),this._serviceSourceType==="mosaic-dataset")return e.multidimensionalDefinition=(a=e.multidimensionalDefinition)==null?void 0:a.filter(f=>f.dimensionName!==o),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];const u=e.multidimensionalDefinition.filter(f=>f.dimensionName===o),p=b(t.start)?t.start.getTime():null,m=b(t.end)?t.end.getTime():null,c=p==null||m==null||p===m,d=c?[p||m]:[[p,m]],g=this.version>=10.8;if(u.length)u.forEach(f=>{f.dimensionName===o&&(g?(f.dimensionName=null,f.isSlice=null,f.values=null):(f.isSlice=c,f.values=d))});else if(!g){const f=e.multidimensionalDefinition.filter(h=>h.variableName!=null&&h.dimensionName==null);f.length?f.forEach(h=>{h.dimensionName=o,h.isSlice=c,h.values=d}):e.multidimensionalDefinition.push(new Pe({variableName:"",dimensionName:o,isSlice:c,values:d}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return ie(e)?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter(t=>!(!t.variableName&&!t.dimensionName)),e.multidimensionalDefinition.length===0&&(e.multidimensionalDefinition=null)),this._serviceSourceType!=="mosaic-dataset"&&e.multidimensionalDefinition==null?null:e)}async _prepareForQuery(e,t){var s;if(await this._fetchCapabilities((s=t)==null?void 0:s.signal),!this.capabilities.operations.supportsQuery)throw new V("imagery-layer:query-rasters","query operation is not supported on the input image service");return e=b(e)?se(Ce,e):this.createQuery(),t=this._getRequestOptions(t),this.raster&&(t.query=J(v({},t.query),{raster:this.raster})),{query:e,requestOptions:t}}async _initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const e=new nr;this._rasterJobHandler.connectionPromise=e.initialize().then(()=>{this._rasterJobHandler.instance=e},()=>null),await this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0}_isSupportedRenderer(e){const{rasterInfo:t,renderingRule:s}=this;return e.type==="unique-value"&&s&&s.functionName.toLowerCase()!=="none"&&t.bandCount===1&&["u8","s8"].includes(t.pixelType)||tr(this.rasterInfo).includes(this.renderer.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){var t;let s=this.sourceJSON;if(!s){const{data:o,ssl:a}=await x(this.parsedUrl.path,{query:this._getQueryParams(),signal:e});s=o,this.sourceJSON=s,a&&(this.url=this.url.replace(/^http:/i,"https:"))}if(((t=s.capabilities)==null?void 0:t.toLowerCase().split(",").map(o=>o.trim()).indexOf("tilesonly"))>-1)throw new V("imagery-layer:fetch-service-info","use ImageryTileLayer to open tiles-only image services");this.read(s,{origin:"service",url:this.parsedUrl})}_isMosaicDataset(e){var t;return e.serviceSourceType?e.serviceSourceType==="esriImageServiceSourceTypeMosaicDataset":((t=e.fields)==null?void 0:t.length)>0}_isMosaicRuleSupported(e){var t;if(!e)return!1;const s=this._isMosaicDataset(e),o=e.currentVersion>=10.71&&e.hasMultidimensions&&e.timeInfo&&!(e.objectIdField&&((t=e.fields)==null?void 0:t.length)>1);return s||o}_isVectorFieldResampleFunction(e){if(!b(e))return!1;const{functionName:t,functionArguments:s}=e,o=t.toLowerCase()==="resample",a=(s==null?void 0:s.ResampleType)||(s==null?void 0:s.resampleType);return o&&(a===7||a===10)}_isPicture(){return!this.format||this.format.indexOf("jpg")>-1||this.format.indexOf("png")>-1}_configDefaultRenderer(){if(!this._isPicture()&&!this.pixelFilter){if(!this.bandIds&&this.rasterInfo.bandCount>=3){const s=rr(this.rasterInfo);!s||this.rasterInfo.bandCount===3&&s[0]===0&&s[1]===1&&s[2]===2||(this.bandIds=s)}var e,t;this.renderer||(this.renderer=ir(this.rasterInfo,{bandIds:this.bandIds,variableName:this.renderingRule?null:(e=this.mosaicRule)==null||(t=e.multidimensionalDefinition)==null?void 0:t[0].variableName})),this._symbolizer?(this._symbolizer.rendererJSON=sr(this.renderer.toJSON()),this._symbolizer.rasterInfo=this.rasterInfo):this._symbolizer=new ar({rendererJSON:this.renderer.toJSON(),rasterInfo:this.rasterInfo}),this._symbolizer.bind().success||(this._symbolizer=null)}}_clonePixelData(e){return e==null?e:{extent:e.extent&&e.extent.clone(),pixelBlock:b(e.pixelBlock)&&e.pixelBlock.clone()}}_getQueryParams(e){const{raster:t,viewId:s}=this;return v(v({raster:t,viewId:s,f:"json"},e),this.customParameters)}_getRequestOptions(e){return J(v({},e),{query:v(v({},e==null?void 0:e.query),this.customParameters)})}_decodePixelBlock(e,t,s){return this._rasterJobHandler.instance?this._rasterJobHandler.instance.decode({data:e,options:t}):Ze(e,t,s)}async _fetchMultidimensionalInfo(e){var t;const s=await x(this.parsedUrl.path+"/multidimensionalInfo",{query:this._getQueryParams(),signal:e}).then(o=>{var a;return(a=o.data)==null?void 0:a.multidimensionalInfo});return(t=s.variables)!=null&&t.length&&s.variables.forEach(o=>{var a;(a=o.statistics)!=null&&a.length&&o.statistics.forEach(u=>{u.avg=u.mean,u.stddev=u.standardDeviation})}),s}async _getRasterFunctionInfos(e){const t=this.sourceJSON.rasterFunctionInfos;return this.serviceRasterInfo?t:t&&this.version>=10.3?t.length===1&&t[0].name.toLowerCase()==="none"?t:x(this.parsedUrl.path+"/rasterFunctionInfos",{query:this._getQueryParams(),signal:e}).then(s=>{var o;return(o=s.data)==null?void 0:o.rasterFunctionInfos}):null}_fetchAuxiliaryRasterInfo(e){const t=e&&e.serviceInfo;if(!t)return Promise.reject(new V("imagery-layer:fetch-metadata","valid serviceInfo is required"));const s=e.renderingRule?JSON.stringify(e.renderingRule.toJSON()):null,o=e.signal,a=!!(t.hasRasterAttributeTable&&this.version>=10.1)&&x(this.parsedUrl.path+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:this.version>=10.1?s:null}),signal:o}).then(d=>Oe.fromJSON(d.data)).catch(()=>null),u=!!(t.hasColormap&&this.version>=10.1)&&x(this.parsedUrl.path+"/colormap",{query:this._getQueryParams({renderingRule:this.version>=10.6?s:null}),signal:o}).then(d=>{var g;return(g=d.data)==null?void 0:g.colormap}),p=!!(t.hasHistograms&&this.version>=10.1)&&x(this.parsedUrl.path+"/histograms",{query:this._getQueryParams({renderingRule:this.version>=10.1?s:null}),signal:o}).then(d=>{var g;return(g=d.data)==null?void 0:g.histograms}),m=this.version>=10.3&&x(this.parsedUrl.path+"/keyProperties",{query:this._getQueryParams({renderingRule:s}),signal:o}).then(d=>d.data).catch(()=>{}),c=!!(t.hasMultidimensions&&this.version>=10.3)&&this._fetchMultidimensionalInfo();return Promise.all([a,u,p,m,c]).then(d=>{let g=null;if(t.minValues&&t.minValues.length===t.bandCount){g=[];for(let R=0;R<t.minValues.length;R++)g.push({min:t.minValues[R],max:t.maxValues[R],avg:t.meanValues[R],stddev:t.stdvValues[R]})}const f=Math.ceil((t.extent.xmax-t.extent.xmin)/t.pixelSizeX-.1),h=Math.ceil((t.extent.ymax-t.extent.ymin)/t.pixelSizeY-.1),y=K.fromJSON(t.spatialReference||t.extent.spatialReference);return new De({width:f,height:h,bandCount:t.bandCount,extent:ye.fromJSON(t.extent),spatialReference:y,pixelSize:new B({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:y}),pixelType:t.pixelType.toLowerCase(),statistics:g,attributeTable:d[0]||null,colormap:d[1]||null,histograms:d[2]||null,keyProperties:d[3]||{},multidimensionalInfo:d[4]||null})})}_requestArrayBuffer(e){const{imageProps:t,requestAsImageElement:s,signal:o}=e;if(s&&!this.pixelFilter&&t.format&&t.format.indexOf("png")>-1)return x(this.parsedUrl.path+"/exportImage",{responseType:"image",query:this._getQueryParams(v({f:"image"},e.imageServiceParameters)),signal:o}).then(p=>({imageElement:p.data,params:t}));const a=this._initJobHandler(),u=x(this.parsedUrl.path+"/exportImage",{responseType:"array-buffer",query:this._getQueryParams(v({f:"image"},e.imageServiceParameters)),signal:o});return Promise.all([u,a]).then(p=>{const m=p[0].data,c=t.format||"jpgpng";let d=c;if(d!=="bsq"&&d!=="bip"&&(d=lr(m)),!d)throw new V("imagery-layer:fetch-image","unsupported format signature "+String.fromCharCode.apply(null,new Uint8Array(m)));const g=c==="gif"||c==="bmp"||c.indexOf("png")>-1&&(d==="png"||d==="jpg"),f={signal:o};return g?Ze(m,v({useCanvas:!0},t),f).then(h=>({pixelData:{pixelBlock:h,extent:t.extent},params:t})):this._decodePixelBlock(m,{width:t.width,height:t.height,planes:null,pixelType:null,noDataValue:null,format:c},f).then(h=>({pixelData:{pixelBlock:h,extent:t.extent},params:t}))})}async _generateRasterInfo(e,t){const{data:s}=await x(this.parsedUrl.path,v({query:this._getQueryParams({renderingRule:e})},t));return await this._fetchAuxiliaryRasterInfo(v({serviceInfo:s,renderingRule:e},t))}_isValidCustomizedMosaicRule(e){return e&&JSON.stringify(e.toJSON())!==JSON.stringify(this._defaultServiceMosaicRule&&this._defaultServiceMosaicRule.toJSON())}_updateMultidimensionalDefinition(e){if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;const t=e.variables[0].dimensions,s="",o=[];for(const a in t)if(t.hasOwnProperty(a)){const u=t[a],p=u.extent;let m=!0,c=[p[0]];u.hasRanges&&u.hasRanges===!0?(m=!1,c=[u.values[0]]):u.name.toLowerCase()==="stdz"&&Math.abs(p[1])<=Math.abs(p[0])&&(c=[p[1]]),o.push(new Pe({variableName:s,dimensionName:t[a].name,isSlice:m,values:c}))}if(o.length>0){this.mosaicRule=this.mosaicRule||new E;const a=this.mosaicRule.multidimensionalDefinition;(!a||a&&a.length<=0)&&(this.mosaicRule.multidimensionalDefinition=o)}}_formatAttributeValue(e,t){if(typeof e=="string"){const s=this.popupTemplate&&this.popupTemplate.fieldInfos,o=this._getFieldInfo(s,t),a=o&&o.format;if(a){let u,p;return e.trim().indexOf(",")>-1?(u=",",p=u+" ",this._formatDelimitedString(e,u,p,a)):e.trim().indexOf(" ")>-1?(u=p=" ",this._formatDelimitedString(e,u,p,a)):this._formatNumberFromString(e,a)}}return e}_getFieldInfo(e,t){if(!e||!e.length||!t)return;const s=t.toLowerCase();let o;return e.some(a=>!(!a.fieldName||a.fieldName.toLowerCase()!==s&&a.fieldName.toLowerCase()!==s.replace(/ /g,"_"))&&(o=a,!0)),o}_formatDelimitedString(e,t,s,o){return e&&t&&s&&o?e.trim().split(t).map(a=>this._formatNumberFromString(a,o)).join(s):e}_formatNumberFromString(e,t){if(!e||!t)return e;const s=Number(e);return isNaN(s)?e:t.format(s)}_processVisibleRastersResponse(e,t){t=t||{};const s=e.value,{templateRRFunctionNames:o,showNoDataRecords:a,returnDomainValues:u,templateFields:p}=t,m=e.processedValues;let c=e.catalogItems&&e.catalogItems.features,d=e.properties&&e.properties.Values&&e.properties.Values.map(N=>N.replace(/ /gi,", "))||[];const g=this.objectIdField||"ObjectId",f=typeof s=="string"&&s.toLowerCase().indexOf("nodata")>-1,h=[];if(s&&!c&&!f){const N={};N[g]=0,d=[s],c=[new Dt(this.fullExtent,null,N)]}if(!c)return[];let y,R,W;this._updateResponseFieldNames(c,p),f&&!a&&(c=[]);for(let N=0;N<c.length;N++){if(y=c[N],s!=null){if(R=d[N],W=this.renderingRule&&m&&m.length>0&&o&&o.length>0&&o.indexOf(this.renderingRule.functionName)>-1?m[o.indexOf(this.renderingRule.functionName)]:s,R.toLowerCase()==="nodata"&&!a)continue;const I="Raster.ItemPixelValue",S="Raster.ServicePixelValue";y.attributes[I]=this._formatAttributeValue(R,I),y.attributes[S]=this._formatAttributeValue(W,S),this._updateFeatureWithMagDirValues(y,R);const k=this.fields&&this.fields.length>0;let Y=this.renderingRule&&b(this.serviceRasterInfo)&&this.serviceRasterInfo.attributeTable?k?R:s:W;this.renderingRule||(Y=k?R:s),this._updateFeatureWithRasterAttributeTableValues(y,Y)}if(y.sourceLayer=this,u&&this._updateFeatureWithDomainValues(y),o&&m&&o.length===m.length)for(let I=0;I<o.length;I++){const S="Raster.ServicePixelValue."+o[I];y.attributes[S]=this._formatAttributeValue(m[I],S)}h.push(c[N])}return h}_updateFeatureWithRasterAttributeTableValues(e,t){const s=this.rasterInfo&&this.rasterInfo.attributeTable||b(this.serviceRasterInfo)&&this.serviceRasterInfo.attributeTable,o=s&&s.features;if(!o)return;const a=s.fields,u=a.map(c=>c.name).filter(c=>c.toLowerCase()==="value"),p=u&&u[0];if(!p)return;const m=o.filter(c=>c.attributes[p]===(t!=null?parseInt(t,10):null));m&&m[0]&&a.forEach(c=>{const d=this.rasterAttributeTableFieldPrefix+c.name;e.attributes[d]=this._formatAttributeValue(m[0].attributes[c.name],d)})}_updateFeatureWithMagDirValues(e,t){if(this.serviceDataType!=="esriImageServiceDataTypeVector-UV"&&this.serviceDataType!=="esriImageServiceDataTypeVector-MagDir")return;const s=t.split(/,\s*/).map(m=>parseFloat(m)),o=s.map(m=>[m]),a=s.map(m=>({minValue:m,maxValue:m,noDataValue:null})),u=new ur({height:1,width:1,pixelType:"f32",pixels:o,statistics:a});this.pixelFilter!=null&&this.pixelFilter({pixelBlock:u,extent:new ye(0,0,0,0,this.spatialReference)});const p=this.serviceDataType==="esriImageServiceDataTypeVector-MagDir"?[u.pixels[0][0],u.pixels[1][0]]:cr([u.pixels[0][0],u.pixels[1][0]]);e.attributes["Raster.Magnitude"]=p[0],e.attributes["Raster.Direction"]=p[1]}_updateFeatureWithDomainValues(e){const t=this.fields&&this.fields.filter(s=>s.domain&&s.domain.type==="coded-value");t!=null&&t.forEach(s=>{const o=e.attributes[s.name];if(o!=null){const a=s.domain.codedValues.filter(u=>u.code===o)[0];a&&(e.attributes[s.name]=a.name)}})}_updateResponseFieldNames(e,t){if(!t||t.length<1)return;const s=this.fieldsIndex;b(s)&&e.forEach(o=>{if(o&&o.attributes){for(const a of t)if(s.has(a)){const u=s.get(a).name;u!==a&&(o.attributes[a]=o.attributes[u],delete o.attributes[u])}}})}_updateRenderingRulesFunctionName(e,t){if(!e||e.length<1)return;if(e==="Raw")return e.replace("Raw","None");const s=e.toLowerCase().replace(/ /gi,"_");return t.has(s)?t.get(s):e}_isRFTJson(e){return e.name&&e.arguments&&e.function&&e.hasOwnProperty("functionType")}_readCapabilities(e){const t=e.capabilities?e.capabilities.toLowerCase().split(",").map(d=>d.trim()):["image","catalog"],{currentVersion:s,advancedQueryCapabilities:o,maxRecordCount:a}=e,u=t.indexOf("image")>-1,p=e.serviceDataType==="esriImageServiceDataTypeElevation",m=!!(e.spatialReference||e.extent&&e.extent.spatialReference),c=t.includes("edit");return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:u,supportsExportImage:u,supportsIdentify:u,supportsMeasure:t.indexOf("mensuration")>-1&&m,supportsDownload:t.indexOf("download")>-1,supportsQuery:t.indexOf("catalog")>-1&&e.fields&&e.fields.length>0,supportsGetSamples:s>=10.2&&u,supportsProject:s>=10.3&&u,supportsComputeStatisticsHistograms:s>=10.4&&u,supportsQueryBoundary:s>=10.6&&u,supportsCalculateVolume:s>=10.7&&p,supportsComputePixelLocation:s>=10.7&&t.indexOf("catalog")>-1,supportsComputeAngles:s>=10.91,supportsAdd:c,supportsDelete:c,supportsEditing:c,supportsUpdate:c,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1},query:{maxRecordCount:a,maxRecordCountFactor:void 0,supportsStatistics:!(o==null||!o.supportsStatistics),supportsOrderBy:!(o==null||!o.supportsOrderBy),supportsDistinct:!(o==null||!o.supportsDistinct),supportsPagination:!(o==null||!o.supportsPagination),supportsStandardizedQueriesOnly:!(o==null||!o.useStandardizedQueries),supportsPercentileStatistics:!(o==null||!o.supportsPercentileStatistics),supportsCentroid:!(o==null||!o.supportsReturningGeometryCentroid),supportsDistance:!(o==null||!o.supportsQueryWithDistance),supportsExtent:!(o==null||!o.supportsReturningQueryExtent),supportsGeometryProperties:!(o==null||!o.supportsReturningGeometryProperties),supportsHavingClause:!(o==null||!o.supportsHavingClause),supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:!1,supportsTopFeaturesQuery:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0}}}};return n([l()],r.prototype,"_functionRasterInfos",void 0),n([l()],r.prototype,"_rasterJobHandler",void 0),n([l()],r.prototype,"_symbolizer",void 0),n([l({dependsOn:["_serviceSupportsMosaicRule"]})],r.prototype,"_defaultServiceMosaicRule",void 0),n([T("_defaultServiceMosaicRule",["defaultMosaicMethod"])],r.prototype,"readDefaultServiceMosaicRule",null),n([l()],r.prototype,"_cachedRendererJson",void 0),n([l({readOnly:!0})],r.prototype,"_serviceSourceType",void 0),n([T("_serviceSourceType",["serviceSourceType","fields"])],r.prototype,"readServiceSourceType",null),n([l({readOnly:!0})],r.prototype,"_serviceSupportsMosaicRule",void 0),n([T("_serviceSupportsMosaicRule",["currentVersion","fields"])],r.prototype,"readServiceSupportsMosaicRule",null),n([l()],r.prototype,"rasterAttributeTableFieldPrefix",void 0),n([l({readOnly:!0})],r.prototype,"rasterFunctionNamesIndex",null),n([l()],r.prototype,"adjustAspectRatio",void 0),n([l({readOnly:!0}),z("serviceRasterInfo.bandCount")],r.prototype,"bandCount",void 0),n([l({type:[le],json:{write:!0}})],r.prototype,"bandIds",void 0),n([T("bandIds")],r.prototype,"readBandIds",null),n([l({readOnly:!0,json:{read:!1}})],r.prototype,"capabilities",void 0),n([T("service","capabilities",["capabilities","currentVersion","serviceDataType"])],r.prototype,"readCapabilities",null),n([l({type:Number})],r.prototype,"compressionQuality",void 0),n([_("compressionQuality")],r.prototype,"writeCompressionQuality",null),n([l({type:Number})],r.prototype,"compressionTolerance",void 0),n([_("compressionTolerance")],r.prototype,"writeCompressionTolerance",null),n([l({json:{read:{source:"copyrightText"}}})],r.prototype,"copyright",void 0),n([l({type:String,json:{name:"layerDefinition.definitionExpression",write:{enabled:!0,allowNull:!0}}})],r.prototype,"definitionExpression",void 0),n([l({readOnly:!0,constructOnly:!0})],r.prototype,"exportImageServiceParameters",void 0),n([l()],r.prototype,"rasterInfo",void 0),n([l({readOnly:!0,type:[re]})],r.prototype,"fields",void 0),n([l({readOnly:!0})],r.prototype,"fieldsIndex",null),n([l({type:["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"],json:{write:!0}})],r.prototype,"format",null),n([T("service","format",["serviceDataType"])],r.prototype,"readFormat",null),n([l({type:ye})],r.prototype,"fullExtent",void 0),n([l({readOnly:!0})],r.prototype,"hasMultidimensions",void 0),n([l({json:{read:{source:"maxImageHeight"}}})],r.prototype,"imageMaxHeight",void 0),n([l({json:{read:{source:"maxImageWidth"}}})],r.prototype,"imageMaxWidth",void 0),n([l({type:String,json:{type:Z.jsonValues,read:Z.read,write:Z.write}})],r.prototype,"interpolation",void 0),n([l()],r.prototype,"minScale",void 0),n([T("service","minScale")],r.prototype,"readMinScale",null),n([l()],r.prototype,"maxScale",void 0),n([T("service","maxScale")],r.prototype,"readMaxScale",null),n([l({type:E})],r.prototype,"mosaicRule",null),n([T("mosaicRule",["mosaicRule","defaultMosaicMethod"])],r.prototype,"readMosaicRule",null),n([_("mosaicRule")],r.prototype,"writeMosaicRule",null),n([l({readOnly:!0}),z("serviceRasterInfo.multidimensionalInfo")],r.prototype,"multidimensionalInfo",void 0),n([l({json:{type:le}})],r.prototype,"noData",void 0),n([_("noData")],r.prototype,"writeNoData",null),n([l({type:String,json:{type:fe.jsonValues,read:fe.read,write:fe.write}})],r.prototype,"noDataInterpretation",void 0),n([l({type:String,readOnly:!0,json:{read:{source:["fields"]}}})],r.prototype,"objectIdField",void 0),n([T("objectIdField")],r.prototype,"readObjectIdField",null),n([l({})],r.prototype,"geometryType",void 0),n([l({})],r.prototype,"typeIdField",void 0),n([l({})],r.prototype,"types",void 0),n([l({readOnly:!0})],r.prototype,"parsedUrl",null),n([l({readOnly:!0}),z("serviceRasterInfo.pixelSize.x")],r.prototype,"pixelSizeX",void 0),n([l({readOnly:!0}),z("serviceRasterInfo.pixelSize.y")],r.prototype,"pixelSizeY",void 0),n([l({type:Function})],r.prototype,"pixelFilter",void 0),n([l()],r.prototype,"raster",void 0),n([l()],r.prototype,"viewId",void 0),n([l({types:Kt,json:{name:"layerDefinition.drawingInfo.renderer",origins:{"web-scene":{types:Zt,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="animated-flow"})}}}}})],r.prototype,"renderer",void 0),n([T("renderer")],r.prototype,"readRenderer",null),n([_("renderer")],r.prototype,"writeRenderer",null),n([l(xt)],r.prototype,"opacity",void 0),n([l({readOnly:!0}),z("serviceRasterInfo.attributeTable")],r.prototype,"rasterAttributeTable",void 0),n([l({readOnly:!0})],r.prototype,"rasterFields",null),n([l({constructOnly:!0})],r.prototype,"rasterFunctionInfos",void 0),n([l({type:C})],r.prototype,"renderingRule",null),n([T("renderingRule",["renderingRule","rasterFunctionInfos"])],r.prototype,"readRenderingRule",null),n([_("renderingRule")],r.prototype,"writeRenderingRule",null),n([l()],r.prototype,"serviceDataType",void 0),n([l({readOnly:!0,type:K})],r.prototype,"spatialReference",void 0),n([T("spatialReference",["spatialReference","extent"])],r.prototype,"readSpatialReference",null),n([l({json:{type:Qe.jsonValues}})],r.prototype,"pixelType",void 0),n([T("pixelType")],r.prototype,"readPixelType",null),n([_("pixelType")],r.prototype,"writePixelType",null),n([l({constructOnly:!0,type:De})],r.prototype,"serviceRasterInfo",void 0),n([l()],r.prototype,"sourceJSON",void 0),n([l(It)],r.prototype,"url",void 0),n([l({readOnly:!0})],r.prototype,"version",void 0),n([T("version",["currentVersion","fields","timeInfo"])],r.prototype,"readVersion",null),r=n([A("esri.layers.mixins.ArcGISImageService")],r),r};let U=class extends Vt($t(Jt(qt(Lt(zt(zr(Et(Ut(kt(Qt)))))))))){constructor(...i){super(...i),this.legendEnabled=!0,this.isReference=null,this.operationalLayerType="ArcGISImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.type="imagery"}normalizeCtorArgs(i,r){return typeof i=="string"?v({url:i},r):i}load(i){const r=b(i)?i.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},i).catch(Ht).then(()=>this._fetchService(r))),Promise.resolve(this)}writeOperationalLayerType(i,r,e){var t;const s=((t=this.renderer)==null?void 0:t.type)==="vector-field";r[e]=s?"ArcGISImageServiceVectorLayer":"ArcGISImageServiceLayer"}get defaultPopupTemplate(){return this.createPopupTemplate()}createPopupTemplate(i){const r=this.rasterFields,e=this.title,t=new Set;let s=!1,o=!1;this.capabilities&&(s=this.capabilities.operations.supportsQuery&&this.fields&&this.fields.length>0,o=s&&(this.serviceDataType==="esriImageServiceDataTypeVector-UV"||this.serviceDataType==="esriImageServiceDataTypeVector-MagDir"));const a=new Set;s&&(a.add("raster.itempixelvalue"),o&&a.add("raster.magnitude").add("raster.direction"));for(const u of r){const p=u.name.toLowerCase();a.has(p)||p.indexOf("raster.servicepixelvalue.")>-1||t.add(u.name)}return Bt({fields:r,title:e},J(v({},i),{visibleFieldNames:t}))}queryFeatures(i,r){return this.queryRasters(i,r).then(e=>{if(e!=null&&e.features)for(const t of e.features)t.layer=t.sourceLayer=this;return e})}queryFeatureCount(i,r){return this.queryRasterCount(i,r)}redraw(){this.emit("redraw")}};n([l(Gt)],U.prototype,"legendEnabled",void 0),n([l({type:["show","hide"]})],U.prototype,"listMode",void 0),n([l({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],U.prototype,"isReference",void 0),n([l({type:["ArcGISImageServiceLayer"],json:{origins:{"web-map":{type:["ArcGISImageServiceLayer","ArcGISImageServiceVectorLayer"],read:!1,write:{target:"layerType",ignoreOrigin:!0}}}}})],U.prototype,"operationalLayerType",void 0),n([_("web-map","operationalLayerType")],U.prototype,"writeOperationalLayerType",null),n([l(Wt)],U.prototype,"popupEnabled",void 0),n([l({type:Xt,json:{read:{source:"popupInfo"},write:{target:"popupInfo"}}})],U.prototype,"popupTemplate",void 0),n([l({readOnly:!0})],U.prototype,"defaultPopupTemplate",null),n([l({readOnly:!0,json:{read:!1}})],U.prototype,"type",void 0),U=n([A("esri.layers.ImageryLayer")],U);const Yr=U;export{Yr as default};
