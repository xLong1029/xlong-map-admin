import{cD as _,r as D,t as k,ez as U,eA as z,e as o,d,i as S,X as O,ik as C,il as L,p as R,$ as A,im as Q,he as X,hg as B,eg as G}from"./index.988b09cd.js";import{n as q}from"./attributeUtils.a1b96ab7.js";const H={setAttribute(){},rollback(){},commit(){}};function re(t,r){const e=r.attributes[t.objectIdField],n=t.sessions.get(e);if(n)return n;const s=_(r.attributes),i=new Set;if(e==null)return H;const u=t.attributeOverrides.createInteractiveEditSession(e),c=new Map,b=(l,m)=>{const p=c.get(l);if(p==null){const f=m.indexOf(e);return c.set(l,f),f}return p};let a=0;const y={setAttribute(l,m){if(a!==0)return;const p=t.fieldsIndex.get(l);if(k(p))return;const f=t.attributeStorageInfo.findIndex(g=>g.name===p.name);if(f<0)return;u.set(f,m);const w=t.attributeStorageInfo[f];let x=!1;i.add(l),t.forEachNode((g,v)=>{const E=b(g,v);if(E===-1)return;const I=t.getAttributeData(g.index);if(I){const N=I[w.name];N&&(N[E]=m,t.setAttributeData(g.index,I,r),x=!0)}}),x&&t.clearMemCache()},rollback(){if(a===0){for(const l of i)this.setAttribute(l,s[l]);u.rollback(),a=1,t.sessions.delete(e)}},commit(){a===0&&(u.commit(),a=2,t.sessions.delete(e))}};return t.sessions.set(e,y),y}function ne(t,r){const e=J(t,r);if(e.size===0)return;const n=new Map;for(let i=0;i<t.attributeStorageInfo.length;i++)n.set(t.attributeStorageInfo[i].name,i);let s=!1;e.forEach((i,u)=>{const c=t.getAttributeData(u);let b=!1;i.forEach((a,y)=>{const l=D(c)?c[y]:null,m=n.get(y);for(const{featureIndex:p,value:f,featureId:w}of a)l&&(l[p]=f,b=!0,s=!0),t.attributeOverrides.updateValue(w,m,f)}),b&&t.setAttributeData(u,c,null)}),s&&t.clearMemCache()}function J(t,r){const e=r.edits.updateFeatures;if(!e||e.length===0)return new V;const n=T(r),s=new V,i=new Map;for(let a=0;a<t.attributeStorageInfo.length;a++)i.set(t.attributeStorageInfo[a].name,a);const u=t.fieldsIndex,c=t.objectIdField,b=e.filter(a=>{const y=q(u,a.attributes,c);return n.has(y)});return t.forEachNode((a,y)=>{const l=new Set(y);for(const m of b){const p=q(u,m.attributes,c);if(!l.has(p))continue;const f=y.indexOf(p);for(const w in m.attributes){const x=t.fieldsIndex.normalizeFieldName(w),g=K(s,a.index,x),v=m.attributes[w];g.push({featureIndex:f,featureId:p,value:v})}}}),s}function K(t,r,e){const n=P(t,r),s=n.get(e);if(s)return s;const i=new Array;return n.set(e,i),i}function P(t,r){const e=t.get(r);if(e)return e;const n=new W;return t.set(r,n),n}function T(t){const r=new Set;if(!t.updatedFeatures)return r;for(const e of t.updatedFeatures)e.objectId!=null&&e.error==null&&r.add(e.objectId);return r}const W=Map,V=Map;function se(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:t,layer:{fieldsIndex:r},requiredFields:e}=this;return t.outFields?U(r,[...z(r,t.outFields),...e]):U(r,e)}}}}const j=t=>{let r=class extends t{constructor(){super(...arguments),this._numUpdating=0,this.asyncUpdateState=new Map}get updating(){return this._numUpdating>0}autoUpdateAsync(e,n){return Y(s=>this.updateAsync(e,s),n)}async updateAsync(e,n){if(!this.startAsyncUpdate(e)){try{const s=await n();this._set(e,s)}catch{O.getLogger(this.declaredClass).warn(`Async update of "${e}" failed. Async update functions should not throw exceptions.`)}this.endAsyncUpdate(e)&&this.updateAsync(e,n)}}startAsyncUpdate(e){var n;const s=(n=this.asyncUpdateState.get(e))!=null?n:0;return 1&s?(this.asyncUpdateState.set(e,2|s),!0):(++this._numUpdating,this.asyncUpdateState.set(e,1|s),!1)}endAsyncUpdate(e){var n;--this._numUpdating;const s=-2&((n=this.asyncUpdateState.get(e))!=null?n:0);return 2&s?(this.asyncUpdateState.set(e,-3&s),!0):(this.asyncUpdateState.set(e,s),!1)}};return o([d({readOnly:!0})],r.prototype,"updating",null),o([d()],r.prototype,"_numUpdating",void 0),r=o([S("esri.core.AsyncUpdate")],r),r};function Y(t,r){const e=()=>{i&&!u&&t(n)},n=()=>{if(!i||u)return r();i.clear(),u=!0;const c=C(i,r);return u=!1,c},s=()=>{i&&(i.destroy(),i=null)};let i=new L(e),u=!1;return t(n),{remove:s}}let M=class extends j(R){};M=o([S("esri.core.AsyncUpdate")],M);const Z=O.getLogger("esri.views.3d.layers.support.SceneLayerViewRequiredFields");let h=class extends j(Q){constructor(t){super(t)}get requiredFields(){const{layerView:{layer:{fieldsIndex:t},definitionExpressionFields:r},rendererFields:e,labelingFields:n,viewFilterFields:s}=this;return U(t,[...A(r,[]),...A(e,[]),...A(n,[]),...A(s,[])])}initialize(){const t=this.layerView.layer;this.layer=t,this.handles.add([this.autoUpdateAsync("rendererFields",()=>{const{fieldsIndex:r,renderer:e}=this.layer;return e?$(n=>e.collectRequiredFields(n,r)):null}),this.autoUpdateAsync("labelingFields",()=>{const{layer:r}=this;return r.labelsVisible?$(e=>X(e,r)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:r,filter:e}=this.layerView;return $(n=>B(n,r,e))})])}};async function $(t){const r=new Set;try{return await t(r),Array.from(r).sort()}catch(e){return Z.error(e),null}}o([d()],h.prototype,"layerView",void 0),o([d()],h.prototype,"layer",void 0),o([d()],h.prototype,"requiredFields",null),o([d()],h.prototype,"rendererFields",void 0),o([d()],h.prototype,"labelingFields",void 0),o([d()],h.prototype,"viewFilterFields",void 0),h=o([S("esri.views.3d.layers.support.SceneLayerViewRequiredFields")],h);class F extends G{constructor(){super(...arguments),this.layer=null,this.filter=null}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(r){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}highlight(r){throw new Error("Not implemented")}queryFeatures(r,e){throw new Error("Not implemented")}queryObjectIds(r,e){throw new Error("Not implemented")}queryFeatureCount(r,e){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(r,e){throw new Error("Not implemented")}}o([d()],F.prototype,"layer",void 0),o([d()],F.prototype,"availableFields",null),o([d()],F.prototype,"maximumNumberOfFeatures",null),o([d({readOnly:!0})],F.prototype,"maximumNumberOfFeaturesExceeded",null),o([d()],F.prototype,"filter",void 0);export{se as a,h as c,ne as i,F as o,re as s};
