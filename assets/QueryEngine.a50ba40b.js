var ve=Object.defineProperty,Ae=Object.defineProperties;var ze=Object.getOwnPropertyDescriptors;var se=Object.getOwnPropertySymbols;var Ve=Object.prototype.hasOwnProperty,Ee=Object.prototype.propertyIsEnumerable;var ie=(h,e,t)=>e in h?ve(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t,L=(h,e)=>{for(var t in e||(e={}))Ve.call(e,t)&&ie(h,t,e[t]);if(se)for(var t of se(e))Ee.call(e,t)&&ie(h,t,e[t]);return h},ae=(h,e)=>Ae(h,ze(e));import{i8 as re,c4 as F,b5 as $,eB as ne,eC as q,b0 as G,eJ as Ce,i9 as oe,ia as le,cs as ue,ib as $e,bP as ce,ic as De,f7 as Pe,c3 as he,b9 as de,ej as D,g_ as Me,g$ as je,id as Oe,fD as W,ie as fe,fH as me,c1 as pe,ig as Ne,e5 as qe,eo as ye,dM as Ge,e0 as ke,cv as Be}from"./vendor.c8f3cc8c.js";import{WhereClause as Ze}from"./WhereClause.23a6eab5.js";import{g as k,M as Le,f as X}from"./projectionSupport.a9ad5f38.js";import{t as Ue}from"./QueryEngineCapabilities.83e56447.js";import{T as He,s as Je,m as ge,c as xe,V as Ye,g as We,h as Xe,y as Ke,D as et,z as tt,f as st,d as it}from"./utils.d8f3ec1d.js";import{z as P,n as at,J as K,O as _e,t as rt,P as M,U as j,v as we,I as Ie,a as Fe}from"./spatialQuerySupport.88aac535.js";class nt{constructor(e,t){this._cache=new re(e),this._invalidCache=new re(t)}get(e,t){const s=`${t.uid}:${e}`,i=this._cache.get(s);if(i)return i;if(this._invalidCache.get(s)!==void 0)return null;try{const a=Ze.create(e,t);return this._cache.put(s,a),a}catch{return this._invalidCache.put(s,null),null}}}const ee=new nt(50,500),v="feature-store:unsupported-query",Se=" as ",ot=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function lt(h,e){if(!e)return!0;const t=ee.get(e,h);if(!t)throw new F(v,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new F(v,"where clause is not standard",{where:e});return A(h,t.fieldNames,"where clause contains missing fields"),!0}function ut(h,e,t){if(!e)return!0;const s=ee.get(e,h);if(!s)throw new F(v,"invalid SQL expression",{having:e});if(!s.isAggregate)throw new F(v,"having does not contain a valid aggregate function",{having:e});const i=s.fieldNames;if(A(h,i,"having contains missing fields"),!s.getExpressions().every(a=>{const{aggregateType:r,field:o}=a,n=h.has(o)&&h.get(o).name;return t.some(l=>{const{onStatisticField:u,statisticType:c}=l;return(h.has(u)&&h.get(u).name)===n&&c.toLowerCase().trim()===r})}))throw new F(v,"expressions in having should also exist in outStatistics",{having:e});return!0}function O(h,e){return h?ee.get(h,e):null}function A(h,e,t,s=!0){const i=[];for(const a of e)if(a!=="*"&&!h.has(a))if(s){const r=be(a);try{const o=O(r,h);if(!o)throw new F(v,"invalid SQL expression",{where:r});if(!o.isStandardized)throw new F(v,"expression is not standard",{clause:o});A(h,o.fieldNames,"expression contains missing fields")}catch(o){const n=o&&o.details;if(n&&(n.clause||n.where))throw o;n&&n.missingFields?i.push(...n.missingFields):i.push(a)}}else i.push(a);if(i.length)throw new F(v,t,{missingFields:i})}function be(h){return h.split(Se)[0]}function ct(h){return h.split(Se)[1]}function ht(h,e){const t=e.get(h);return!!t&&!ot.has(t.type)}class U{constructor(e,t,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=s,this.featureAdapter=t;const i=e.outFields;if(i&&i.indexOf("*")===-1){this.outFields=i;let a=0;for(const r of i){const o=be(r),n=this.fieldsIndex.get(o),l=n?null:O(o,s),u=n?n.name:ct(r)||"FIELD_EXP_"+a++;this._fieldDataCache.set(r,{alias:u,clause:l})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,s){const i=s?s.name:t;let a=null;return this._fieldDataCache.has(i)?a=this._fieldDataCache.get(i).clause:s||(a=O(t,this.fieldsIndex),this._fieldDataCache.set(i,{alias:i,clause:a})),s?this.featureAdapter.getAttribute(e,i):a.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const s=t.normalizationType,i=t.normalizationTotal;let a=this.getFieldValue(e,t.field,t.fieldInfo);if(s&&Number.isFinite(a)){const r=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);a=He(a,s,r,i)}return a}getExpressionValue(e,t,s){const i={attributes:this.featureAdapter.getAttributes(e)},a=s.createExecContext(i,t.viewInfo);return s.executeFunction(t.compiledFunc,a)}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:O(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:O(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const s={};for(const i of t){const{alias:a,clause:r}=this._fieldDataCache.get(i);s[a]=r?r.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,a)}return s}_processAttributesForDistinctValues(e){if($(e)||!this.returnDistinctValues)return e;const t=this.outFields,s=[];if(t)for(const r of t){const{alias:o}=this._fieldDataCache.get(r);s.push(e[o])}else for(const r in e)s.push(e[r]);const i=`${(t||["*"]).join(",")}=${s.join(",")}`;let a=this._returnDistinctMap.get(i)||0;return this._returnDistinctMap.set(i,++a),a>1?null:e}}class S{constructor(e,t,s){this.items=e,this.queryGeometry=t,this.definitionExpression=s.definitionExpression,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.fieldsIndex=s.fieldsIndex,this.timeInfo=s.timeInfo,this.featureAdapter=s.featureAdapter,this.aggregateAdapter=s.aggregateAdapter}get size(){return this.items.length}createQueryResponseForCount(e){const t=new U(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:s,having:i}=e;if(!(s==null?void 0:s.length))return 1;const a=new Map,r=new Map,o=new Set,n=e.outStatistics;for(const l of n){const{statisticType:u}=l,c=u!=="exceedslimit"?l.onStatisticField:void 0;if(!r.has(c)){const p=[];for(const d of s){const _=this._getAttributeValues(t,d,a);p.push(_)}r.set(c,this._calculateUniqueValues(p,t.returnDistinctValues))}const m=r.get(c);for(const p in m){const{data:d,items:_}=m[p],f=d.join(",");i&&!t.validateItems(_,i)||o.add(f)}}return o.size}createQueryResponse(e){let t;return e.outStatistics?t=e.outStatistics.some(s=>s.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(e):this._createStatisticsQueryResponse(e):t=this._createFeatureQueryResponse(e),e.returnQueryGeometry&&(ne(e.outSR)&&!q(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=P(L({spatialReference:e.outSR},k(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR))):t.queryGeometry=P(L({spatialReference:e.outSR},this.queryGeometry))),t}createSnappingResponse(e,t){const s=this.featureAdapter,i=ft(this.hasZ,this.hasM),{x:a,y:r}=e.point,o=typeof e.distance=="number"?e.distance:e.distance.x,n=typeof e.distance=="number"?e.distance:e.distance.y,l={candidates:[]},u=this.geometryType==="esriGeometryPolygon",c=this.getPointCreator(e.point,this.spatialReference,t);for(const m of this.items){const p=s.getGeometry(m);if($(p))continue;const{coords:d,lengths:_}=p;if(1&e.types){let f=0;for(let y=0;y<_.length;y++){const I=_[y];for(let w=0;w<I;w++,f+=i){const b=d[f],x=d[f+1];if(w!==I-1){const g=d[f+i],T=d[f+i+1],{x:B,y:Q}=dt(a,r,b,x,g,T),V=(a-B)/o,C=(r-Q)/n,E=V*V+C*C;E<=1&&l.candidates.push({type:"edge",objectId:s.getObjectId(m),distance:Math.sqrt(E),target:c(B,Q),start:c(b,x),end:c(g,T)})}}}}if(2&e.types){const f=u?d.length-i:d.length;for(let y=0;y<f;y+=i){const I=d[y],w=d[y+1],b=(a-I)/o,x=(r-w)/n,g=b*b+x*x;g<=1&&l.candidates.push({type:"vertex",objectId:s.getObjectId(m),distance:Math.sqrt(g),target:c(I,w)})}}}return l.candidates.sort((m,p)=>m.distance-p.distance),l}getPointCreator(e,t,s){const i=G(s)&&!q(t,s)?a=>k(a,t,s):a=>a;return e.z!=null&&e.m!=null?(a,r)=>i({x:a,y:r,z:e.z,m:e.m}):e.z!=null?(a,r)=>i({x:a,y:r,z:e.z}):e.m!=null?(a,r)=>i({x:a,y:r,m:e.m}):(a,r)=>i({x:a,y:r})}executeAttributesQuery(e){const t=O(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let s=0;const i=[];for(const r of this.items)t.testFeature(r,this.featureAdapter)&&(i[s++]=r);const a=new S(i,this.queryGeometry,this);return a.definitionExpression=e.where,Promise.resolve(a)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(e){if(!e.aggregateIds||!e.aggregateIds.length||$(this.aggregateAdapter))return Promise.resolve(this);const t=new Set;for(const i of e.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach(a=>t.add(a));const s=this.featureAdapter.getObjectId;return Promise.resolve(new S(this.items.filter(i=>t.has(s(i))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),s=this.featureAdapter.getObjectId;return Promise.resolve(new S(this.items.filter(i=>t.has(s(i))),this.queryGeometry,this))}executeTimeQuery(e){const t=at(this.timeInfo,e.timeExtent,this.featureAdapter);if(!G(t))return Promise.resolve(this);const s=this.items.filter(t);return Promise.resolve(new S(s,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:s}=this.timeInfo,i=s||t,a=new Map,r=this.featureAdapter.getAttribute;for(const n of this.items){const l=r(n,e),u=r(n,i),c=a.get(l);(!c||u>r(c,i))&&a.set(l,n)}const o=Array.from(a.values());return Promise.resolve(new S(o,this.queryGeometry,this))}async project(e){if(!e||q(this.spatialReference,e))return this;const t=this.featureAdapter,s=(await Le(this.items.map(i=>K(this.geometryType,this.hasZ,this.hasM,t.getGeometry(i))),this.spatialReference,e)).map((i,a)=>t.cloneWithGeometry(this.items[a],Ce(i,this.hasZ,this.hasM)));return new S(s,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:s,valueExpression:i,normalizationField:a,normalizationType:r,normalizationTotal:o,minValue:n,maxValue:l,scale:u}=t,c=this.fieldsIndex.isDateField(s),m=await this._getDataValues(e,{field:s,valueExpression:i,normalizationField:a,normalizationType:r,normalizationTotal:o,scale:u}),p=Je({normalizationType:r,normalizationField:a,minValue:n,maxValue:l}),d=this.fieldsIndex.get(s),_={value:.5,fieldType:d==null?void 0:d.type},f=oe(d)?ge({values:m,supportsNullCount:p,percentileParams:_}):xe({values:m,minValue:n,maxValue:l,useSampleStdDev:!r,supportsNullCount:p,percentileParams:_});return Ye(f,c)}async createUniqueValuesResponse(e,t){const{field:s,valueExpression:i,domain:a,returnAllCodedValues:r,scale:o}=t,n=await this._getDataValues(e,{field:s,valueExpression:i,scale:o}),l=We(n);return Xe(l,a,r)}async createClassBreaksResponse(e,t){const{field:s,valueExpression:i,normalizationField:a,normalizationType:r,normalizationTotal:o,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:m,scale:p}=t,d=await this._getDataValues(e,{field:s,valueExpression:i,normalizationField:a,normalizationType:r,normalizationTotal:o,scale:p}),_=Ke(d,{field:s,normalizationField:a,normalizationType:r,normalizationTotal:o,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:m});return et(_,n)}async createHistogramResponse(e,t){const{field:s,valueExpression:i,normalizationField:a,normalizationType:r,normalizationTotal:o,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:m,scale:p}=t,d=await this._getDataValues(e,{field:s,valueExpression:i,normalizationField:a,normalizationType:r,normalizationTotal:o,scale:p});return tt(d,{field:s,normalizationField:a,normalizationType:r,normalizationTotal:o,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:m})}_sortFeatures(e,t,s){if(e.length>1&&t&&t.length)for(const i of t.reverse()){const a=i.split(" "),r=a[0],o=this.fieldsIndex.get(r),n=a[1]&&a[1].toLowerCase()==="desc",l=st(o==null?void 0:o.type,n);e.sort((u,c)=>{const m=s(u,r,o),p=s(c,r,o);return l(m,p)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:i,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:n,outSR:l,quantizationParameters:u,resultRecordCount:c,resultOffset:m,returnZ:p,returnM:d}=e,_=c!=null&&t.length>(m||0)+c,f=n&&(n.includes("*")?[...this.fieldsIndex.fields]:n.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:_,features:this._createFeatures(e,t),fields:f,geometryType:s,hasM:i&&d,hasZ:a&&p,objectIdFieldName:r,spatialReference:P(l||o),transform:u&&le(u)||null}}_createFeatures(e,t){const s=new U(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:a}=this,{orderByFields:r,quantizationParameters:o,returnGeometry:n,returnCentroid:l,maxAllowableOffset:u,resultOffset:c,resultRecordCount:m,returnZ:p=!1,returnM:d=!1}=e,_=a&&p,f=i&&d;let y=[],I=0;const w=[...t];if(this._sortFeatures(w,r,(x,g,T)=>s.getFieldValue(x,g,T)),n||l){const x=le(o);if(n&&!l)for(const g of w)y[I++]={attributes:s.getAttributes(g),geometry:K(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),u,x,_,f)};else if(!n&&l)for(const g of w)y[I++]={attributes:s.getAttributes(g),centroid:_e(this,this.featureAdapter.getCentroid(g,this),x)};else for(const g of w)y[I++]={attributes:s.getAttributes(g),centroid:_e(this,this.featureAdapter.getCentroid(g,this),x),geometry:K(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),u,x,_,f)}}else for(const x of w){const g=s.getAttributes(x);g&&(y[I++]={attributes:g})}const b=c||0;if(m!=null){const x=b+m;y=y.slice(b,Math.min(y.length,x))}return y}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const r of e.outStatistics)if(r.statisticType==="exceedslimit"){s=r.maxPointCount!=null?r.maxPointCount:Number.POSITIVE_INFINITY,i=r.maxRecordCount!=null?r.maxRecordCount:Number.POSITIVE_INFINITY,a=r.maxVertexCount!=null?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>s;else if(this.items.length>i)t=!0;else{const r=this.hasZ?this.hasM?4:3:this.hasM?3:2,o=this.featureAdapter;t=this.items.reduce((n,l)=>{const u=o.getGeometry(l);return n+(G(u)&&u.coords.length||0)},0)/r>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}_createStatisticsQueryResponse(e){const t={attributes:{}},s=[],i=new Map,a=new Map,r=new Map,o=new Map,n=new U(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:u,having:c,orderByFields:m}=e,p=u&&u.length,d=!!p,_=d&&u[0],f=d&&!this.fieldsIndex.get(_);for(const I of l){const{outStatisticFieldName:w,statisticType:b}=I,x=I,g=b!=="exceedslimit"?I.onStatisticField:void 0,T=b==="percentile_disc"||b==="percentile_cont",B=d&&p===1&&(g===_||f)&&b==="count";if(d){if(!r.has(g)){const V=[];for(const C of u){const E=this._getAttributeValues(n,C,i);V.push(E)}r.set(g,this._calculateUniqueValues(V,n.returnDistinctValues))}const Q=r.get(g);for(const V in Q){const{count:C,data:E,items:Te,itemPositions:Re}=Q[V],te=E.join(",");if(!c||n.validateItems(Te,c)){const J=o.get(te)||{attributes:{}};let Y=null;if(B)Y=C;else{const Z=this._getAttributeValues(n,g,i),N=Re.map(Qe=>Z[Qe]);Y=T&&"statisticParameters"in x?this._getPercentileValue(x,N):this._getStatisticValue(x,N,null,n.returnDistinctValues)}J.attributes[w]=Y,u.forEach((Z,N)=>J.attributes[this.fieldsIndex.get(Z)?Z:`EXPR_${N+1}`]=E[N]),o.set(te,J)}}}else{const Q=this._getAttributeValues(n,g,i);t.attributes[w]=T&&"statisticParameters"in x?this._getPercentileValue(x,Q):this._getStatisticValue(x,Q,a,n.returnDistinctValues)}s.push({name:w,alias:w,type:"esriFieldTypeDouble"})}const y=d?Array.from(o.values()):[t];return this._sortFeatures(y,m,(I,w)=>I.attributes[w]),{fields:s,features:y}}_getStatisticValue(e,t,s,i){const{onStatisticField:a,statisticType:r}=e;let o=null;return o=s!=null&&s.has(a)?s.get(a):oe(this.fieldsIndex.get(a))?ge({values:t,returnDistinct:i}):xe({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(a,o),o[r==="var"?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:a}=e,{value:r,orderBy:o}=i,n=this.fieldsIndex.get(s),l={value:r,orderBy:o,fieldType:n==null?void 0:n.type,isDiscrete:a==="percentile_disc"};return it(t,l)}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const i=this.fieldsIndex.get(t),a=this.items.map(r=>e.getFieldValue(r,t,i));return s.set(t,a),a}_getAttributeNormalizedValues(e,t){return this.items.map(s=>e.getNormalizedValue(s,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,s){const{arcadeUtils:i}=await ue(),a=i.createFunction(t),r=s&&i.getViewInfo(s);return this.items.map(o=>e.getExpressionValue(o,{compiledFunc:a,viewInfo:r},i))}_calculateUniqueValues(e,t){const s={},i=this.items,a=i.length;for(let r=0;r<a;r++){const o=i[r],n=[];for(const u of e)n.push(u[r]);const l=n.join(",");t?s[l]==null&&(s[l]={count:1,data:n,items:[o],itemPositions:[r]}):s[l]==null?s[l]={count:1,data:n,items:[o],itemPositions:[r]}:(s[l].count++,s[l].items.push(o),s[l].itemPositions.push(r))}return s}async _getDataValues(e,t){const s=new U(e,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:a,normalizationField:r,normalizationType:o,normalizationTotal:n,scale:l}=t,u=i?{viewingMode:"map",scale:l,spatialReference:e.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(s,i,u):this._getAttributeNormalizedValues(s,{field:a,normalizationField:r,normalizationType:o,normalizationTotal:n})}}function dt(h,e,t,s,i,a){const r=i-t,o=a-s,n=r*r+o*o,l=(h-t)*r+(e-s)*o,u=Math.min(1,Math.max(0,l/n));return{x:t+r*u,y:s+o*u}}function ft(h,e){return h?e?4:3:e?3:2}function mt(h){return h.every(e=>e.statisticType!=="exceedslimit")}const z="feature-store:unsupported-query",H=new Set,pt=new $e(2e6);let yt=0;class Tt{constructor(e){this.capabilities={query:Ue},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new De(yt+++"$$",pt)),this.fieldsIndex=new Pe(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=he(this._frameTask),this.clearCache(),de(this._geometryQueryCache),this._changeHandle=he(this._changeHandle),de(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:P(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=rt(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let s,i=D(e);try{i=await this._schedule(()=>M(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t)}catch(a){if(a!==j)throw a;s=new S([],null,this)}return s.createQueryResponse(i)}async executeQueryForCount(e={},t){let s=D(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>M(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t);let i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t);return i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i.createQueryResponseForCount(s)}catch(i){if(i!==j)throw i;return 0}}async executeQueryForExtent(e={},t){let s,i=D(e);const a=i.outSR;try{i=await this._schedule(()=>M(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),i.returnGeometry=!0,i.returnCentroid=!1,i.outSR=null,s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const r=s.size;if(!r)return{count:r,extent:null};Me(R,je),this.featureStore.forEachBounds(s.items,l=>Oe(R,l),gt);const o={xmin:R[0],ymin:R[1],xmax:R[3],ymax:R[4],spatialReference:P(this.spatialReference)};this.hasZ&&isFinite(R[2])&&isFinite(R[5])&&(o.zmin=R[2],o.zmax=R[5]);const n=k(o,s.spatialReference,a);if(n.spatialReference=P(a||this.spatialReference),n.xmax-n.xmin==0){const l=W(n.spatialReference);n.xmin-=l,n.xmax+=l}if(n.ymax-n.ymin==0){const l=W(n.spatialReference);n.ymin-=l,n.ymax+=l}if(this.hasZ&&n.zmin!=null&&n.zmax!=null&&n.zmax-n.zmin==0){const l=W(n.spatialReference);n.zmin-=l,n.zmax+=l}return{count:r,extent:n}}catch(r){if(r===j)return{count:0,extent:null};throw r}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(s=>Array.from(s))}async executeQueryForIdSet(e={},t){let s,i=D(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>M(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const a=s.items,r=new Set;return await this._reschedule(()=>{for(const o of a)r.add(s.featureAdapter.getObjectId(o))},t),r}catch(a){if(a===j)return new Set;throw a}}async executeQueryForSnapping(e,t){const{point:s,distance:i,types:a}=e;if(a===0)return{candidates:[]};const r=await this._reschedule(()=>this._checkQuerySupport(e.query),t),o=!q(s.spatialReference,this.spatialReference);o&&await X(s.spatialReference,this.spatialReference);const n=typeof i=="number"?i:i.x,l=typeof i=="number"?i:i.y,u={xmin:s.x-n,xmax:s.x+n,ymin:s.y-l,ymax:s.y+l,spatialReference:s.spatialReference},c=o?k(u,this.spatialReference):u;if(!c)return{candidates:[]};const m=(await fe(me(s),null,{signal:t}))[0],p=(await fe(me(c),null,{signal:t}))[0];if($(m)||$(p))return{candidates:[]};let d=new S(this._searchFeatures(this._getQueryBBoxes(p.toJSON())),null,this);d=await this._reschedule(()=>d.executeObjectIdsQuery(r),t),d=await this._reschedule(()=>d.executeTimeQuery(r),t),d=await this._reschedule(()=>d.executeAttributesQuery(r),t);const _=m.toJSON(),f=o?k(_,this.spatialReference):_,y=o?Math.max(c.xmax-c.xmin,c.ymax-c.ymin)/2:i;return d.createSnappingResponse(ae(L({},e),{point:f,distance:y}),s.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new F(z,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let s,i=D(e);try{i=await this._schedule(()=>M(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s=await this._reschedule(()=>s.filterLatest(),t)}catch(a){if(a!==j)throw a;s=new S([],null,this)}return s.createQueryResponse(i)}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:a,valueExpression:r},s)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,valueExpression:a},s)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:a,valueExpression:r},s)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:a,valueExpression:r},s)).createHistogramResponse(e,t)}async _schedule(e,t){return G(this._frameTask)?this._frameTask.schedule(e,t):e(pe)}async _reschedule(e,t){return G(this._frameTask)?this._frameTask.reschedule(e,t):e(pe)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new S(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:s,outSR:i,spatialRel:a,returnGeometry:r,returnCentroid:o}=e,n=r||o,l=ne(i)&&!q(this.spatialReference,i),u=this._geometryQueryCache?l&&n?JSON.stringify({geometry:s,spatialRelationship:a,outSpatialReference:i}):JSON.stringify({geometry:s,spatialRelationship:a}):null;if(u){const f=this._geometryQueryCache.get(u);if(!Ne(f))return f}const c=async f=>{if(l&&n){const y=await f.project(i);return u&&this._geometryQueryCache.put(u,y,y.size||1),y}return u&&this._geometryQueryCache.put(u,f,f.size||1),f};if(!s)return c(this._getAll());const m=this.featureAdapter;if(a==="esriSpatialRelDisjoint"){const f=this._searchFeatures(this._getQueryBBoxes(s));if(!f.length)return c(this._getAll());let y,I;const w=new Set;for(const x of f)w.add(m.getObjectId(x));await this._reschedule(()=>{let x=0;y=new Array(w.size),this.featureStore.forEach(g=>y[x++]=g),I=w},t);const b=await this._reschedule(async()=>{const x=await we(a,s,this.geometryType,this.hasZ,this.hasM),g=T=>!I.has(m.getObjectId(T))||x(m.getGeometry(T));return new S(await this._runSpatialFilter(y,g,t),s,this)},t);return c(b)}const p=this._searchFeatures(this._getQueryBBoxes(s));if(!p.length){const f=new S([],s,this);return u&&this._geometryQueryCache.put(u,f,f.size||1),f}if(this._canExecuteSoloPass(s,e))return c(new S(p,s,this));const d=await we(a,s,this.geometryType,this.hasZ,this.hasM),_=await this._runSpatialFilter(p,f=>d(m.getGeometry(f)),t);return c(new S(_,s,this))}async _runSpatialFilter(e,t,s){if(!t)return e;if($(this._frameTask))return e.filter(o=>t(o));let i=0;const a=new Array,r=async o=>{for(;i<e.length;){const n=e[i++];t(n)&&(a.push(n),o.madeProgress()),o.done&&await this._reschedule(l=>r(l),s)}};return this._reschedule(o=>r(o),s).then(()=>a)}_canExecuteSoloPass(e,t){const{geometryType:s}=this,{spatialRel:i}=t;return Ie(e)&&(i==="esriSpatialRelEnvelopeIntersects"||s==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"||i==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(Ie(e)){if(qe(e))return[ye(e.xmin,e.ymin,e.xmax,e.ymax)];if(Ge(e))return e.rings.map(t=>ye(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[ke(Be(),e)]}_searchFeatures(e){for(const i of e)this.featureStore.forEachInBounds(i,a=>{H.add(a)});const t=new Array(H.size);let s=0;return H.forEach(i=>t[s++]=i),H.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new F(z,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),Fe(e,this.geometryType,this.spatialReference),X(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:s}=await ue();t=s.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new F(z,"params should have at least a field or valueExpression",{params:e});A(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new F(z,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Fe(e,this.geometryType,this.spatialReference),X(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:i,outStatistics:a}=e,r=a?a.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()):[];if(s&&s.length>0){const o=" asc",n=" desc",l=s.map(u=>{const c=u.toLowerCase();return c.indexOf(o)>-1?c.split(o)[0]:c.indexOf(n)>-1?c.split(n)[0]:u}).filter(u=>r.indexOf(u)===-1);A(this.fieldsIndex,l,"orderByFields contains missing fields")}if(t&&t.length>0)A(this.fieldsIndex,t,"outFields contains missing fields");else if(i)throw new F(z,"outFields should be specified for returnDistinctValues",{query:e});lt(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:i}=e,a=s&&s.length,r=t&&t.length;if(i){if(!a||!r)throw new F(z,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});ut(this.fieldsIndex,i,t)}if(r){if(!mt(t))return;const o=t.map(n=>n.onStatisticField);A(this.fieldsIndex,o,"onStatisticFields contains missing fields"),a&&A(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const n of t){const{onStatisticField:l,statisticType:u}=n;if((u==="percentile_disc"||u==="percentile_cont")&&"statisticParameters"in n){const{statisticParameters:c}=n;if(!c)throw new F(z,"statisticParamters should be set for percentile type",{definition:n,query:e})}else if(u!=="count"&&l&&ht(l,this.fieldsIndex))throw new F(z,"outStatistics contains non-numeric fields",{definition:n,query:e})}}}async _getQueryEngineResultForStats(e={},t,s){let i;e=D(e);try{e=await this._schedule(()=>M(e,this.definitionExpression,this.spatialReference),s),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),s),i=await this._reschedule(()=>this._executeGeometryQuery(e,s),s),i=await this._reschedule(()=>i.executeAggregateIdsQuery(e),s),i=await this._reschedule(()=>i.executeObjectIdsQuery(e),s),i=await this._reschedule(()=>i.executeTimeQuery(e),s),i=await this._reschedule(()=>i.executeAttributesQuery(e),s)}catch(a){if(a!==j)throw a;i=new S([],null,this)}return i}}const gt=ce(),R=ce();export{Tt as L};
