import{e as u,y as g,b as I,g5 as S,ak as F,qQ as b,cP as G,qR as k,qS as V,qT as C,qU as D,h8 as z,gQ as m,h9 as q,qV as f,gY as L,gP as P,hJ as J,qW as A,ba as Q,qX as U,qY as W,qZ as Z,aR as H,r as T,nB as X,q_ as K,n3 as w,q$ as tt,r0 as B,r1 as rt,i as h,r2 as $,r3 as y,r4 as nt,r5 as et,nE as at,r6 as ot,r7 as it,r8 as st,fD as lt,ab as ct,ms as pt,h7 as ut,r9 as gt,ra as ht,rb as ft}from"./index.a33ecea7.js";var v;let p=v=class extends S{constructor(t){super(t),this.origin=F(),this.translation=F(),this.rotation=b(),this.scale=G(1,1,1),this.geographic=!0}get localMatrix(){const t=m();return k(E,C(this.rotation),V(this.rotation)),D(t,E,this.translation,this.scale),t}get localMatrixInverse(){return z(m(),this.localMatrix)}applyLocal(t,r){return q(r,t,this.localMatrix)}applyLocalInverse(t,r){return q(r,t,this.localMatrixInverse)}project(t,r){const n=new Float64Array(t.length),e=f.fromTypedArray(n),a=f.fromTypedArray(t);if(this.geographic){const s=L(r),c=m();return P(r,this.origin,c,s),J(c,c,this.localMatrix),A(e,a,c),Q(n,s,0,n,r,0,n.length/3),n}const{localMatrix:o,origin:i}=this;U(o,W)?Z(e,a):A(e,a,o);for(let s=0;s<n.length;s+=3)n[s+0]+=i[0],n[s+1]+=i[1],n[s+2]+=i[2];return n}getOriginPoint(t){const[r,n,e]=this.origin;return new H({x:r,y:n,z:e,spatialReference:t})}equals(t){return T(t)&&this.geographic===t.geographic&&X(this.origin,t.origin)&&K(this.localMatrix,t.localMatrix)}clone(){const t={origin:w(this.origin),translation:w(this.translation),rotation:b(this.rotation),scale:w(this.scale),geographic:this.geographic};return new v(t)}};u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"origin",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),u([g({type:Boolean,nonNullable:!0,json:{write:!0}})],p.prototype,"geographic",void 0),u([g()],p.prototype,"localMatrix",null),u([g()],p.prototype,"localMatrixInverse",null),p=v=u([I("esri.geometry.support.MeshTransform")],p);const E=tt(),yt=p;function R(t,r){var n;return t.isGeographic||t.isWebMercator&&((n=r==null?void 0:r.geographic)!=null?n:!0)}function _(t,r,n){return R(r.spatialReference,n)?$t(t,r,n):At(t,r,n)}function mt(t,r,n){const{position:e,normal:a,tangent:o}=t;if(h(r))return{position:e,normal:a,tangent:o};const i=r.localMatrix;return _({position:gt(e,new Float64Array(e.length),i),normal:T(a)?ht(a,new Float32Array(a.length),i):null,tangent:T(o)?ft(o,new Float32Array(o.length),i):null},r.getOriginPoint(n),{geographic:r.geographic})}function Et(t,r,n){var e;if(n!=null&&n.useTransform){const{position:a,normal:o,tangent:i}=t;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new yt({origin:[r.x,r.y,(e=r.z)!=null?e:0],geographic:R(r.spatialReference,n)})}}return{vertexAttributes:_(t,r,n),transform:null}}function N(t,r,n){return R(r.spatialReference,n)?vt(t,r,n):j(t,r,n)}function Nt(t,r,n,e){if(h(r))return N(t,n,e);const a=mt(t,r,n.spatialReference);return n.equals(r.getOriginPoint(n.spatialReference))?j(a,n,e):N(a,n,e)}function At(t,r,n){const e=new Float64Array(t.position.length),a=t.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:x}=d(n?n.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=a[l+0]*c+o,e[l+1]=a[l+1]*c+i,e[l+2]=a[l+2]*x+s;return{position:e,normal:t.normal,tangent:t.tangent}}function $t(t,r,n){const e=r.spatialReference,a=O(r,n,M),o=new Float64Array(t.position.length),i=xt(t.position,a,e,o),s=B(Y,a);return{position:i,normal:wt(i,o,t.normal,s,e),tangent:Tt(i,o,t.tangent,s,e)}}function xt(t,r,n,e){A(f.fromTypedArray(e),f.fromTypedArray(t),r);const a=new Float64Array(t.length);return rt(e,a,n)}function wt(t,r,n,e,a){if(h(n))return null;const o=new Float32Array(n.length);return $(y.fromTypedArray(o),y.fromTypedArray(n),e),nt(o,t,r,a,o),o}function Tt(t,r,n,e,a){if(h(n))return null;const o=new Float32Array(n.length);$(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=n[i];return et(o,t,r,a,o),o}function j(t,r,n){const e=new Float64Array(t.position.length),a=t.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:x}=d(n?n.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=(a[l+0]-o)/c,e[l+1]=(a[l+1]-i)/c,e[l+2]=(a[l+2]-s)/x;return{position:e,normal:t.normal,tangent:t.tangent}}function vt(t,r,n){const e=r.spatialReference;O(r,n,M);const a=z(Ft,M),o=new Float64Array(t.position.length),i=Mt(t.position,e,a,o),s=B(Y,a);return{position:i,normal:Rt(t.normal,t.position,o,e,s),tangent:dt(t.tangent,t.position,o,e,s)}}function O(t,r,n){P(t.spatialReference,[t.x,t.y,t.z||0],n,L(t.spatialReference));const{horizontal:e,vertical:a}=d(r?r.unit:null,t.spatialReference);return at(n,n,[e,e,a]),n}function Mt(t,r,n,e){const a=ot(t,r,e),o=f.fromTypedArray(a),i=new Float64Array(a.length),s=f.fromTypedArray(i);return A(s,o,n),i}function Rt(t,r,n,e,a){if(h(t))return null;const o=it(t,r,n,e,new Float32Array(t.length)),i=y.fromTypedArray(o);return $(i,i,a),o}function dt(t,r,n,e,a){if(h(t))return null;const o=st(t,r,n,e,new Float32Array(t.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return $(i,i,a),o}function d(t,r){if(h(t))return bt;const n=r.isGeographic?1:lt(r),e=r.isGeographic?1:ct(r),a=pt(1,t,"meters");return{horizontal:a*n,vertical:a*e}}const M=m(),Ft=m(),Y=ut(),bt={horizontal:1,vertical:1};export{yt as L,Nt as M,Et as _,N as b,mt as k,R as r,_ as x};
